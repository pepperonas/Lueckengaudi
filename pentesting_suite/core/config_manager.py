import os
import json
import yaml
from pathlib import Path
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, asdict
import jsonschema
from cryptography.fernet import Fernet


@dataclass
class TargetProfile:
    name: str
    hosts: List[str]
    excluded_hosts: Optional[List[str]] = None
    rate_limit: int = 10
    safe_mode: bool = False
    tags: Optional[List[str]] = None
    custom_options: Optional[Dict[str, Any]] = None


class ConfigManager:
    def __init__(self, config_dir: str = "config"):
        self.config_dir = Path(config_dir)
        self.config_dir.mkdir(exist_ok=True)
        self.config = {}
        self.profiles: Dict[str, TargetProfile] = {}
        self._encryption_key = self._get_or_create_key()
        self._fernet = Fernet(self._encryption_key)
        
        self._init_default_config()
        self.load_config()
    
    def _get_or_create_key(self) -> bytes:
        key_file = self.config_dir / ".key"
        if key_file.exists():
            return key_file.read_bytes()
        else:
            key = Fernet.generate_key()
            key_file.write_bytes(key)
            os.chmod(key_file, 0o600)
            return key
    
    def _init_default_config(self):
        self.config = {
            "general": {
                "log_level": "INFO",
                "log_file": "pentesting_suite.log",
                "output_dir": "reports",
                "theme": "dark",
                "primary_color": "#2C2E3B"
            },
            "security": {
                "target_whitelist": [],
                "require_confirmation": True,
                "audit_logging": True,
                "safe_mode_default": False,
                "max_concurrent_scans": 5
            },
            "network": {
                "timeout": 30,
                "retries": 3,
                "proxy": None,
                "user_agent": "PentestingSuite/1.0"
            },
            "reporting": {
                "default_format": "json",
                "include_timestamps": True,
                "include_raw_data": False,
                "executive_summary": True
            }
        }
    
    def load_config(self):
        config_file = self.config_dir / "config.yaml"
        if config_file.exists():
            with open(config_file, 'r') as f:
                loaded_config = yaml.safe_load(f)
                self._merge_configs(self.config, loaded_config)
        
        self._load_profiles()
    
    def save_config(self):
        config_file = self.config_dir / "config.yaml"
        with open(config_file, 'w') as f:
            yaml.dump(self.config, f, default_flow_style=False)
        
        os.chmod(config_file, 0o600)
    
    def _merge_configs(self, base: Dict, update: Dict):
        for key, value in update.items():
            if key in base and isinstance(base[key], dict) and isinstance(value, dict):
                self._merge_configs(base[key], value)
            else:
                base[key] = value
    
    def get(self, path: str, default: Any = None) -> Any:
        keys = path.split('.')
        value = self.config
        
        for key in keys:
            if isinstance(value, dict) and key in value:
                value = value[key]
            else:
                return default
        
        return value
    
    def set(self, path: str, value: Any):
        keys = path.split('.')
        config = self.config
        
        for key in keys[:-1]:
            if key not in config:
                config[key] = {}
            config = config[key]
        
        config[keys[-1]] = value
        self.save_config()
    
    def _load_profiles(self):
        profiles_dir = self.config_dir / "profiles"
        profiles_dir.mkdir(exist_ok=True)
        
        for profile_file in profiles_dir.glob("*.yaml"):
            try:
                with open(profile_file, 'r') as f:
                    profile_data = yaml.safe_load(f)
                    profile = TargetProfile(**profile_data)
                    self.profiles[profile.name] = profile
            except Exception as e:
                print(f"Failed to load profile {profile_file}: {e}")
    
    def save_profile(self, profile: TargetProfile):
        profiles_dir = self.config_dir / "profiles"
        profiles_dir.mkdir(exist_ok=True)
        
        profile_file = profiles_dir / f"{profile.name}.yaml"
        with open(profile_file, 'w') as f:
            yaml.dump(asdict(profile), f, default_flow_style=False)
        
        self.profiles[profile.name] = profile
    
    def get_profile(self, name: str) -> Optional[TargetProfile]:
        return self.profiles.get(name)
    
    def list_profiles(self) -> List[str]:
        return list(self.profiles.keys())
    
    def encrypt_sensitive(self, data: str) -> str:
        return self._fernet.encrypt(data.encode()).decode()
    
    def decrypt_sensitive(self, encrypted: str) -> str:
        return self._fernet.decrypt(encrypted.encode()).decode()
    
    def is_target_allowed(self, target: str) -> bool:
        whitelist = self.get("security.target_whitelist", [])
        if not whitelist:
            return True
        
        return any(target.startswith(allowed) for allowed in whitelist)
    
    def validate_config(self) -> bool:
        schema = {
            "type": "object",
            "properties": {
                "general": {
                    "type": "object",
                    "properties": {
                        "log_level": {"type": "string", "enum": ["DEBUG", "INFO", "WARNING", "ERROR"]},
                        "log_file": {"type": "string"},
                        "output_dir": {"type": "string"}
                    }
                },
                "security": {
                    "type": "object",
                    "properties": {
                        "target_whitelist": {"type": "array", "items": {"type": "string"}},
                        "require_confirmation": {"type": "boolean"},
                        "audit_logging": {"type": "boolean"}
                    }
                }
            }
        }
        
        try:
            jsonschema.validate(self.config, schema)
            return True
        except jsonschema.ValidationError:
            return False