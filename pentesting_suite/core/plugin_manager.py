import os
import importlib
import inspect
from typing import Dict, List, Optional, Type
from pathlib import Path
import asyncio
from concurrent.futures import ThreadPoolExecutor

from .base_plugin import BasePlugin, PluginResult
from .logger import Logger


class PluginManager:
    def __init__(self, plugin_dir: str = "plugins"):
        self.plugin_dir = Path(plugin_dir)
        self.plugins: Dict[str, BasePlugin] = {}
        self.logger = Logger(__name__)
        self._executor = ThreadPoolExecutor(max_workers=10)
        
    def discover_plugins(self):
        if not self.plugin_dir.exists():
            self.logger.warning(f"Plugin directory {self.plugin_dir} does not exist")
            return
        
        for plugin_path in self.plugin_dir.rglob("*.py"):
            if plugin_path.name.startswith("_"):
                continue
                
            try:
                self._load_plugin(plugin_path)
            except Exception as e:
                self.logger.error(f"Failed to load plugin from {plugin_path}: {e}")
    
    def _load_plugin(self, plugin_path: Path):
        module_name = plugin_path.stem
        spec = importlib.util.spec_from_file_location(module_name, plugin_path)
        
        if spec and spec.loader:
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            for name, obj in inspect.getmembers(module):
                if (inspect.isclass(obj) and 
                    issubclass(obj, BasePlugin) and 
                    obj is not BasePlugin):
                    
                    plugin_instance = obj()
                    self.register_plugin(plugin_instance)
                    self.logger.info(f"Loaded plugin: {plugin_instance.name}")
    
    def register_plugin(self, plugin: BasePlugin):
        if plugin.name in self.plugins:
            self.logger.warning(f"Plugin {plugin.name} already registered, overwriting")
        
        self.plugins[plugin.name] = plugin
    
    def get_plugin(self, name: str) -> Optional[BasePlugin]:
        return self.plugins.get(name)
    
    def list_plugins(self) -> List[Dict[str, str]]:
        return [
            {
                "name": plugin.name,
                "version": plugin.version,
                "description": plugin.description,
                "status": plugin.status.value
            }
            for plugin in self.plugins.values()
        ]
    
    async def execute_plugin(self, plugin_name: str, target: str, options: Dict) -> Optional[PluginResult]:
        plugin = self.get_plugin(plugin_name)
        if not plugin:
            self.logger.error(f"Plugin {plugin_name} not found")
            return None
        
        if not plugin.validate_options(options):
            self.logger.error(f"Invalid options for plugin {plugin_name}")
            return None
        
        try:
            self.logger.info(f"Executing plugin {plugin_name} on target {target}")
            result = await plugin.execute(target, options)
            return result
        except Exception as e:
            self.logger.error(f"Plugin {plugin_name} execution failed: {e}")
            return PluginResult(
                plugin_name=plugin_name,
                status=plugin.status,
                data={"error": str(e)},
                errors=[str(e)]
            )
    
    async def execute_multiple(self, plugins: List[str], target: str, options: Dict) -> List[PluginResult]:
        tasks = []
        for plugin_name in plugins:
            if plugin_name in self.plugins:
                task = self.execute_plugin(plugin_name, target, options)
                tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return [r for r in results if isinstance(r, PluginResult)]
    
    def cleanup(self):
        self._executor.shutdown(wait=True)
        for plugin in self.plugins.values():
            plugin.reset()