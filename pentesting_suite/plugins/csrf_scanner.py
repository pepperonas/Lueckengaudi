import asyncio
import aiohttp
from bs4 import BeautifulSoup
import re
from typing import Dict, Any, List, Tuple, Optional
from datetime import datetime
import urllib.parse
import sys
sys.path.append('..')

from core.base_plugin import BasePlugin, PluginResult, PluginStatus, Vulnerability, Severity


class CSRFScanner(BasePlugin):
    def __init__(self):
        super().__init__(
            name="CSRFScanner",
            version="1.0.0",
            description="Cross-Site Request Forgery (CSRF) vulnerability scanner"
        )
        
        # Common CSRF token names
        self.csrf_token_names = [
            "csrf_token", "csrf", "_token", "authenticity_token",
            "csrfmiddlewaretoken", "csrftoken", "_csrf", "csrf_key",
            "security_token", "form_token", "_csrf_token", "request_token",
            "verification_token", "anti_csrf_token", "xsrf_token", "_xsrf"
        ]
        
        # HTTP methods that should be protected against CSRF
        self.csrf_methods = ["POST", "PUT", "DELETE", "PATCH"]
        
        # Common sensitive form patterns
        self.sensitive_form_patterns = [
            r"password",
            r"transfer",
            r"payment",
            r"delete",
            r"admin",
            r"settings",
            r"profile",
            r"account",
            r"user",
            r"edit",
            r"update",
            r"change"
        ]
        
        # Header names that might contain CSRF tokens
        self.csrf_header_names = [
            "X-CSRF-Token", "X-CSRFToken", "X-XSRF-TOKEN",
            "X-Requested-With", "X-CSRF-Protection"
        ]
    
    def validate_options(self, options: Dict[str, Any]) -> bool:
        return "url" in options
    
    async def execute(self, target: str, options: Dict[str, Any]) -> PluginResult:
        self.status = PluginStatus.RUNNING
        
        url = options.get("url", f"http://{target}")
        if not url.startswith(("http://", "https://")):
            url = f"http://{url}"
        
        max_concurrent = options.get("max_concurrent", 5)
        timeout = options.get("timeout", 10)
        test_depth = options.get("depth", 2)  # How deep to crawl for forms
        
        vulnerabilities_found = []
        
        try:
            connector = aiohttp.TCPConnector(limit=max_concurrent)
            timeout_config = aiohttp.ClientTimeout(total=timeout)
            
            async with aiohttp.ClientSession(
                connector=connector,
                timeout=timeout_config,
                headers={"User-Agent": "Mozilla/5.0 (Compatible CSRF Scanner)"}
            ) as session:
                
                # Discover forms and test for CSRF protection
                forms_data = await self._discover_forms(session, url, test_depth)
                
                for form_data in forms_data:
                    vuln = await self._test_csrf_protection(session, form_data)
                    if vuln:
                        vulnerabilities_found.append(vuln)
                
                # Test API endpoints if any are discovered
                api_endpoints = await self._discover_api_endpoints(session, url)
                for endpoint in api_endpoints:
                    vuln = await self._test_api_csrf(session, endpoint)
                    if vuln:
                        vulnerabilities_found.append(vuln)
                
        except Exception as e:
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": str(e)},
                errors=[str(e)]
            )
        
        # Add vulnerabilities to the plugin
        for vuln_data in vulnerabilities_found:
            vuln = Vulnerability(
                title=f"Cross-Site Request Forgery (CSRF) - {vuln_data['type']}",
                description=vuln_data['description'],
                severity=vuln_data['severity'],
                affected_component=vuln_data['url'],
                recommendation=vuln_data['recommendation'],
                evidence=vuln_data['evidence']
            )
            self.add_vulnerability(vuln)
        
        self.status = PluginStatus.COMPLETED
        result_data = {
            "target": target,
            "url": url,
            "forms_tested": len(forms_data),
            "vulnerabilities_found": len(vulnerabilities_found),
            "vulnerability_details": vulnerabilities_found,
            "timestamp": datetime.now().isoformat()
        }
        
        result = PluginResult(
            plugin_name=self.name,
            status=self.status,
            data=result_data,
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(result)
        return result
    
    async def _discover_forms(self, session: aiohttp.ClientSession, url: str, depth: int) -> List[Dict]:
        """Discover forms on the website"""
        forms_data = []
        visited_urls = set()
        urls_to_visit = [url]
        
        for current_depth in range(depth):
            if not urls_to_visit:
                break
            
            current_urls = urls_to_visit.copy()
            urls_to_visit.clear()
            
            for current_url in current_urls:
                if current_url in visited_urls:
                    continue
                
                visited_urls.add(current_url)
                
                try:
                    if self._rate_limiter:
                        async with self._rate_limiter:
                            page_forms = await self._extract_forms_from_page(session, current_url)
                    else:
                        page_forms = await self._extract_forms_from_page(session, current_url)
                    
                    forms_data.extend(page_forms)
                    
                    # Extract links for next depth level
                    if current_depth < depth - 1:
                        links = await self._extract_links(session, current_url)
                        urls_to_visit.extend(links)
                
                except Exception:
                    continue
        
        return forms_data
    
    async def _extract_forms_from_page(self, session: aiohttp.ClientSession, url: str) -> List[Dict]:
        """Extract forms from a single page"""
        forms = []
        
        try:
            async with session.get(url) as response:
                if response.status != 200:
                    return forms
                
                content = await response.text()
                soup = BeautifulSoup(content, 'html.parser')
                
                for form in soup.find_all('form'):
                    form_data = self._analyze_form(form, url)
                    if form_data:
                        forms.append(form_data)
        
        except Exception:
            pass
        
        return forms
    
    def _analyze_form(self, form, page_url: str) -> Optional[Dict]:
        """Analyze a form for CSRF protection"""
        action = form.get('action', '')
        method = form.get('method', 'GET').upper()
        
        # Resolve relative URLs
        if action:
            form_url = urllib.parse.urljoin(page_url, action)
        else:
            form_url = page_url
        
        # Extract all form fields
        fields = {}
        csrf_tokens = []
        
        for input_tag in form.find_all(['input', 'textarea', 'select']):
            name = input_tag.get('name', '')
            input_type = input_tag.get('type', 'text')
            value = input_tag.get('value', '')
            
            if name:
                fields[name] = {
                    'type': input_type,
                    'value': value
                }
                
                # Check if this might be a CSRF token
                if any(token_name in name.lower() for token_name in self.csrf_token_names):
                    csrf_tokens.append({
                        'name': name,
                        'value': value,
                        'type': input_type
                    })
        
        # Determine if this form handles sensitive operations
        is_sensitive = self._is_sensitive_form(form, fields)
        
        return {
            'url': form_url,
            'page_url': page_url,
            'method': method,
            'fields': fields,
            'csrf_tokens': csrf_tokens,
            'is_sensitive': is_sensitive,
            'form_html': str(form)[:500]  # Truncated for evidence
        }
    
    def _is_sensitive_form(self, form, fields: Dict) -> bool:
        """Determine if a form handles sensitive operations"""
        form_text = str(form).lower()
        
        # Check form content against sensitive patterns
        for pattern in self.sensitive_form_patterns:
            if re.search(pattern, form_text):
                return True
        
        # Check field names
        for field_name in fields.keys():
            if any(pattern in field_name.lower() for pattern in self.sensitive_form_patterns):
                return True
        
        # Check for password fields
        for field_data in fields.values():
            if field_data.get('type') == 'password':
                return True
        
        return False
    
    async def _extract_links(self, session: aiohttp.ClientSession, url: str) -> List[str]:
        """Extract links from a page for crawling"""
        links = []
        
        try:
            async with session.get(url) as response:
                if response.status != 200:
                    return links
                
                content = await response.text()
                soup = BeautifulSoup(content, 'html.parser')
                
                base_domain = urllib.parse.urlparse(url).netloc
                
                for link in soup.find_all('a', href=True):
                    href = link['href']
                    absolute_url = urllib.parse.urljoin(url, href)
                    
                    # Only follow links on the same domain
                    if urllib.parse.urlparse(absolute_url).netloc == base_domain:
                        links.append(absolute_url)
        
        except Exception:
            pass
        
        return links[:10]  # Limit to prevent excessive crawling
    
    async def _test_csrf_protection(self, session: aiohttp.ClientSession, form_data: Dict) -> Optional[Dict]:
        """Test a form for CSRF protection"""
        
        # Skip GET forms as they shouldn't be vulnerable to CSRF
        if form_data['method'] not in self.csrf_methods:
            return None
        
        # Check if form has CSRF tokens
        has_csrf_token = len(form_data['csrf_tokens']) > 0
        is_sensitive = form_data['is_sensitive']
        
        # Test 1: Check if CSRF token is present for sensitive forms
        if is_sensitive and not has_csrf_token:
            return {
                'type': 'Missing CSRF Protection',
                'description': f"Sensitive form at {form_data['url']} lacks CSRF protection",
                'severity': Severity.HIGH,
                'url': form_data['url'],
                'recommendation': "Implement CSRF tokens for all state-changing operations",
                'evidence': {
                    'form_method': form_data['method'],
                    'form_fields': list(form_data['fields'].keys()),
                    'csrf_tokens_found': has_csrf_token,
                    'is_sensitive_operation': is_sensitive,
                    'page_url': form_data['page_url']
                }
            }
        
        # Test 2: Try to submit form without CSRF token (if it has one)
        if has_csrf_token:
            csrf_bypass = await self._test_csrf_bypass(session, form_data)
            if csrf_bypass:
                return csrf_bypass
        
        # Test 3: Check for weak CSRF protection
        weak_protection = await self._test_weak_csrf(session, form_data)
        if weak_protection:
            return weak_protection
        
        return None
    
    async def _test_csrf_bypass(self, session: aiohttp.ClientSession, form_data: Dict) -> Optional[Dict]:
        """Test if CSRF protection can be bypassed"""
        
        # Prepare form data without CSRF token
        test_data = {}
        csrf_token_names = []
        
        for field_name, field_info in form_data['fields'].items():
            if not any(token_name in field_name.lower() for token_name in self.csrf_token_names):
                test_data[field_name] = field_info.get('value', 'test_value')
            else:
                csrf_token_names.append(field_name)
        
        try:
            if self._rate_limiter:
                async with self._rate_limiter:
                    response = await self._submit_form(session, form_data['url'], test_data, form_data['method'])
            else:
                response = await self._submit_form(session, form_data['url'], test_data, form_data['method'])
            
            # Check if the request was successful without CSRF token
            if response and response.status in [200, 302, 301]:
                return {
                    'type': 'CSRF Token Bypass',
                    'description': f"Form at {form_data['url']} accepts requests without CSRF token",
                    'severity': Severity.HIGH,
                    'url': form_data['url'],
                    'recommendation': "Ensure CSRF tokens are mandatory and properly validated",
                    'evidence': {
                        'form_method': form_data['method'],
                        'response_status': response.status,
                        'csrf_tokens_bypassed': csrf_token_names,
                        'submitted_without_token': True
                    }
                }
        
        except Exception:
            pass
        
        return None
    
    async def _test_weak_csrf(self, session: aiohttp.ClientSession, form_data: Dict) -> Optional[Dict]:
        """Test for weak CSRF protection implementation"""
        
        csrf_tokens = form_data['csrf_tokens']
        if not csrf_tokens:
            return None
        
        # Test with empty CSRF token
        for csrf_token in csrf_tokens:
            test_data = {}
            for field_name, field_info in form_data['fields'].items():
                if field_name == csrf_token['name']:
                    test_data[field_name] = ''  # Empty token
                else:
                    test_data[field_name] = field_info.get('value', 'test_value')
            
            try:
                if self._rate_limiter:
                    async with self._rate_limiter:
                        response = await self._submit_form(session, form_data['url'], test_data, form_data['method'])
                else:
                    response = await self._submit_form(session, form_data['url'], test_data, form_data['method'])
                
                if response and response.status in [200, 302, 301]:
                    return {
                        'type': 'Weak CSRF Protection',
                        'description': f"Form at {form_data['url']} accepts empty CSRF token",
                        'severity': Severity.MEDIUM,
                        'url': form_data['url'],
                        'recommendation': "Ensure CSRF tokens are properly validated and non-empty",
                        'evidence': {
                            'form_method': form_data['method'],
                            'response_status': response.status,
                            'empty_token_accepted': True,
                            'csrf_token_field': csrf_token['name']
                        }
                    }
            
            except Exception:
                continue
        
        return None
    
    async def _submit_form(self, session: aiohttp.ClientSession, url: str, 
                          data: Dict, method: str) -> Optional:
        """Submit form data to test CSRF protection"""
        try:
            if method.upper() == 'POST':
                return await session.post(url, data=data, allow_redirects=False)
            elif method.upper() == 'PUT':
                return await session.put(url, data=data, allow_redirects=False)
            elif method.upper() == 'DELETE':
                return await session.delete(url, data=data, allow_redirects=False)
            elif method.upper() == 'PATCH':
                return await session.patch(url, data=data, allow_redirects=False)
        except Exception:
            pass
        
        return None
    
    async def _discover_api_endpoints(self, session: aiohttp.ClientSession, url: str) -> List[Dict]:
        """Discover API endpoints that might be vulnerable to CSRF"""
        endpoints = []
        
        # Common API paths to check
        api_paths = [
            "/api/", "/api/v1/", "/api/v2/", "/rest/", "/graphql",
            "/admin/api/", "/user/api/", "/account/api/"
        ]
        
        base_url = f"{urllib.parse.urlparse(url).scheme}://{urllib.parse.urlparse(url).netloc}"
        
        for api_path in api_paths:
            test_url = base_url + api_path
            
            try:
                async with session.get(test_url) as response:
                    if response.status in [200, 404, 401, 403]:
                        endpoints.append({
                            'url': test_url,
                            'status': response.status,
                            'content_type': response.headers.get('Content-Type', '')
                        })
            except Exception:
                continue
        
        return endpoints
    
    async def _test_api_csrf(self, session: aiohttp.ClientSession, endpoint: Dict) -> Optional[Dict]:
        """Test API endpoints for CSRF protection"""
        
        # Test if API accepts simple POST requests without proper headers
        test_data = {'test': 'csrf_test'}
        
        try:
            async with session.post(endpoint['url'], json=test_data) as response:
                # Check if API accepts the request without proper CSRF protection
                if response.status in [200, 201, 202]:
                    # Check if response indicates successful operation
                    content_type = response.headers.get('Content-Type', '')
                    
                    if 'json' in content_type:
                        return {
                            'type': 'API CSRF Vulnerability',
                            'description': f"API endpoint {endpoint['url']} lacks CSRF protection",
                            'severity': Severity.MEDIUM,
                            'url': endpoint['url'],
                            'recommendation': "Implement proper CSRF protection for API endpoints (e.g., SameSite cookies, custom headers)",
                            'evidence': {
                                'endpoint_type': 'API',
                                'response_status': response.status,
                                'content_type': content_type,
                                'accepts_post_without_protection': True
                            }
                        }
        
        except Exception:
            pass
        
        return None