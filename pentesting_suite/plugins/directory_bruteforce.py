import asyncio
import aiohttp
from typing import Dict, Any, List
from datetime import datetime
from pathlib import Path
import sys
sys.path.append('..')

from core.base_plugin import BasePlugin, PluginResult, PluginStatus, Vulnerability, Severity


class DirectoryBruteforce(BasePlugin):
    def __init__(self):
        super().__init__(
            name="DirectoryBruteforce",
            version="1.0.0",
            description="Directory and file bruteforcing for web applications"
        )
        
        self.common_directories = [
            "admin", "administrator", "api", "app", "assets", "backup", "backups",
            "bin", "blog", "cache", "cgi", "cgi-bin", "cms", "config", "conf",
            "content", "control", "css", "data", "database", "db", "debug",
            "dev", "docs", "download", "downloads", "files", "ftp", "help",
            "home", "images", "img", "include", "includes", "index", "info",
            "install", "js", "lib", "library", "log", "logs", "mail", "media",
            "old", "panel", "private", "public", "root", "scripts", "secret",
            "secure", "server", "setup", "shop", "site", "src", "static",
            "system", "temp", "tmp", "tools", "upload", "uploads", "user",
            "users", "utils", "web", "webroot", "www", "xml"
        ]
        
        self.common_files = [
            "index.html", "index.php", "default.html", "default.php",
            "admin.php", "login.php", "config.php", "database.php",
            "robots.txt", "sitemap.xml", ".htaccess", "web.config",
            "phpinfo.php", "info.php", "test.php", "backup.sql",
            "readme.txt", "changelog.txt", "version.txt", "install.txt",
            ".env", ".git/config", ".svn/entries", "composer.json",
            "package.json", "wp-config.php", "configuration.php"
        ]
        
        self.common_extensions = [
            ".php", ".asp", ".aspx", ".jsp", ".html", ".htm", ".txt",
            ".xml", ".json", ".bak", ".old", ".backup", ".sql", ".log"
        ]
        
        self.sensitive_patterns = {
            "config": ["config", "configuration", "settings"],
            "admin": ["admin", "administrator", "panel", "control"],
            "backup": ["backup", "bak", "old", "copy"],
            "database": ["db", "database", "sql", "mysql"],
            "development": ["dev", "test", "debug", "staging"],
            "sensitive": [".env", ".git", ".svn", "composer", "package"]
        }
    
    def validate_options(self, options: Dict[str, Any]) -> bool:
        return "url" in options
    
    async def execute(self, target: str, options: Dict[str, Any]) -> PluginResult:
        self.status = PluginStatus.RUNNING
        
        url = options.get("url", f"http://{target}")
        if not url.startswith(("http://", "https://")):
            url = f"http://{url}"
        
        wordlist = options.get("wordlist", None)
        extensions = options.get("extensions", self.common_extensions)
        max_concurrent = options.get("max_concurrent", 20)
        timeout = options.get("timeout", 5)
        
        found_items = []
        
        try:
            connector = aiohttp.TCPConnector(limit=max_concurrent)
            timeout_config = aiohttp.ClientTimeout(total=timeout)
            
            async with aiohttp.ClientSession(
                connector=connector,
                timeout=timeout_config,
                headers={"User-Agent": "Mozilla/5.0 (Compatible Security Scanner)"}
            ) as session:
                
                # Use custom wordlist or default
                if wordlist and Path(wordlist).exists():
                    targets = await self._load_wordlist(wordlist)
                else:
                    targets = self.common_directories + self.common_files
                
                # Add extensions to directories
                extended_targets = []
                for target_path in targets:
                    extended_targets.append(target_path)
                    if not target_path.endswith(('.txt', '.php', '.html', '.htm', '.xml', '.json')):
                        for ext in extensions[:5]:  # Limit extensions for performance
                            extended_targets.append(f"{target_path}{ext}")
                
                # Perform bruteforce
                found_items = await self._bruteforce_paths(session, url, extended_targets)
                
        except Exception as e:
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": str(e)},
                errors=[str(e)]
            )
        
        # Analyze findings for vulnerabilities
        self._analyze_findings(found_items, url)
        
        self.status = PluginStatus.COMPLETED
        result_data = {
            "target": target,
            "url": url,
            "found_paths": found_items,
            "total_found": len(found_items),
            "timestamp": datetime.now().isoformat()
        }
        
        result = PluginResult(
            plugin_name=self.name,
            status=self.status,
            data=result_data,
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(result)
        return result
    
    async def _load_wordlist(self, wordlist_path: str) -> List[str]:
        """Load custom wordlist from file"""
        try:
            with open(wordlist_path, 'r') as f:
                return [line.strip() for line in f if line.strip()]
        except Exception:
            return self.common_directories + self.common_files
    
    async def _bruteforce_paths(self, session: aiohttp.ClientSession, base_url: str, paths: List[str]) -> List[Dict]:
        """Perform the actual bruteforce attack"""
        found_items = []
        semaphore = asyncio.Semaphore(20)  # Limit concurrent requests
        
        tasks = []
        for path in paths:
            task = self._check_path(session, base_url, path, semaphore)
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for result in results:
            if isinstance(result, dict) and result:
                found_items.append(result)
        
        return found_items
    
    async def _check_path(self, session: aiohttp.ClientSession, base_url: str, path: str, semaphore: asyncio.Semaphore) -> Dict:
        """Check if a specific path exists"""
        async with semaphore:
            if self._rate_limiter:
                async with self._rate_limiter:
                    return await self._perform_request(session, base_url, path)
            return await self._perform_request(session, base_url, path)
    
    async def _perform_request(self, session: aiohttp.ClientSession, base_url: str, path: str) -> Dict:
        """Perform the actual HTTP request"""
        url = f"{base_url.rstrip('/')}/{path.lstrip('/')}"
        
        try:
            async with session.get(url, allow_redirects=False) as response:
                if response.status in [200, 301, 302, 403]:
                    content_length = response.headers.get('Content-Length', '0')
                    content_type = response.headers.get('Content-Type', 'unknown')
                    
                    return {
                        "path": path,
                        "url": url,
                        "status_code": response.status,
                        "content_length": content_length,
                        "content_type": content_type,
                        "redirect_location": response.headers.get('Location', '')
                    }
        except Exception:
            pass
        
        return {}
    
    def _analyze_findings(self, found_items: List[Dict], base_url: str):
        """Analyze found paths for potential vulnerabilities"""
        for item in found_items:
            path = item.get('path', '').lower()
            status_code = item.get('status_code', 0)
            
            # Check for sensitive directories/files
            for category, patterns in self.sensitive_patterns.items():
                if any(pattern in path for pattern in patterns):
                    severity = self._determine_severity(category, status_code)
                    
                    vuln = Vulnerability(
                        title=f"Sensitive {category.title()} Directory/File Exposed",
                        description=f"Found potentially sensitive {category} path: {item.get('url')}",
                        severity=severity,
                        affected_component=item.get('url', ''),
                        recommendation=f"Restrict access to {category} files and directories",
                        evidence={
                            "path": path,
                            "status_code": status_code,
                            "content_type": item.get('content_type', ''),
                            "content_length": item.get('content_length', '')
                        }
                    )
                    
                    self.add_vulnerability(vuln)
                    break
            
            # Check for directory listings (large content length on directory paths)
            if (status_code == 200 and 
                not any(ext in path for ext in ['.php', '.html', '.txt', '.xml']) and
                int(item.get('content_length', '0')) > 1000):
                
                vuln = Vulnerability(
                    title="Directory Listing Enabled",
                    description=f"Directory listing appears to be enabled: {item.get('url')}",
                    severity=Severity.MEDIUM,
                    affected_component=item.get('url', ''),
                    recommendation="Disable directory listing in web server configuration",
                    evidence=item
                )
                
                self.add_vulnerability(vuln)
            
            # Check for backup files
            if any(ext in path for ext in ['.bak', '.backup', '.old', '.sql']):
                vuln = Vulnerability(
                    title="Backup File Exposed",
                    description=f"Backup file found: {item.get('url')}",
                    severity=Severity.HIGH,
                    affected_component=item.get('url', ''),
                    recommendation="Remove backup files from web-accessible directories",
                    evidence=item
                )
                
                self.add_vulnerability(vuln)
    
    def _determine_severity(self, category: str, status_code: int) -> Severity:
        """Determine vulnerability severity based on category and access level"""
        if status_code == 200:  # Directly accessible
            if category in ["config", "database", "sensitive"]:
                return Severity.CRITICAL
            elif category in ["admin", "backup"]:
                return Severity.HIGH
            else:
                return Severity.MEDIUM
        elif status_code == 403:  # Forbidden but exists
            if category in ["config", "database", "sensitive"]:
                return Severity.HIGH
            else:
                return Severity.MEDIUM
        else:  # Redirects
            return Severity.LOW