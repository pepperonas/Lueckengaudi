import asyncio
import dns.resolver
import dns.query
import dns.zone
import dns.exception
from typing import Dict, Any, List, Tuple, Optional
from datetime import datetime
import socket
import sys
sys.path.append('..')

from core.base_plugin import BasePlugin, PluginResult, PluginStatus, Vulnerability, Severity


class DNSEnumerator(BasePlugin):
    def __init__(self):
        super().__init__(
            name="DNSEnumerator", 
            version="1.0.0",
            description="DNS enumeration and security testing"
        )
        
        # Common DNS record types to query
        self.record_types = [
            'A', 'AAAA', 'CNAME', 'MX', 'NS', 'TXT', 'SOA', 'PTR',
            'SRV', 'CAA', 'DNSKEY', 'DS', 'NSEC', 'NSEC3'
        ]
        
        # Common subdomains to test
        self.common_subdomains = [
            'www', 'mail', 'ftp', 'admin', 'test', 'dev', 'staging',
            'api', 'blog', 'shop', 'store', 'support', 'help',
            'docs', 'portal', 'app', 'secure', 'vpn', 'remote',
            'backup', 'db', 'database', 'sql', 'mysql', 'oracle',
            'ldap', 'ad', 'dc', 'ns1', 'ns2', 'dns', 'mx1', 'mx2',
            'smtp', 'pop', 'imap', 'webmail', 'email', 'mail1',
            'mail2', 'exchange', 'owa', 'autodiscover', 'lyncdiscover',
            'sip', 'voip', 'pbx', 'git', 'svn', 'cvs', 'ci', 'jenkins',
            'build', 'puppet', 'chef', 'ansible', 'salt', 'nagios',
            'zabbix', 'monitor', 'logging', 'elk', 'kibana', 'grafana'
        ]
        
        # Common SRV service names
        self.srv_services = [
            '_sip._tcp', '_sip._udp', '_sips._tcp', '_h323cs._tcp',
            '_h323ls._udp', '_ldap._tcp', '_ldaps._tcp', '_gc._tcp',
            '_kerberos._tcp', '_kerberos._udp', '_kpasswd._tcp',
            '_kpasswd._udp', '_autodiscover._tcp', '_caldav._tcp',
            '_carddav._tcp', '_xmpp-client._tcp', '_xmpp-server._tcp',
            '_jabber._tcp', '_msrpc._tcp', '_smtp._tcp', '_submission._tcp',
            '_imap._tcp', '_imaps._tcp', '_pop3._tcp', '_pop3s._tcp'
        ]
        
        # DNS servers to try for zone transfers
        self.dns_servers = []
        
        self.dns_timeout = 5
    
    def validate_options(self, options: Dict[str, Any]) -> bool:
        return "domain" in options
    
    async def execute(self, target: str, options: Dict[str, Any]) -> PluginResult:
        self.status = PluginStatus.RUNNING
        
        domain = options.get("domain", target)
        dns_servers = options.get("dns_servers", [])
        test_subdomains = options.get("test_subdomains", True)
        test_zone_transfer = options.get("test_zone_transfer", True)
        test_dnssec = options.get("test_dnssec", True)
        wordlist_file = options.get("wordlist", None)
        
        # Respect safe mode
        if self.is_safe_mode:
            test_zone_transfer = False
            test_subdomains = True  # Keep subdomain enumeration as it's passive
        
        dns_analysis = {
            "domain": domain,
            "dns_records": {},
            "subdomains": [],
            "zone_transfer": {},
            "name_servers": [],
            "mail_servers": [],
            "srv_records": [],
            "dnssec_info": {},
            "vulnerabilities": []
        }
        
        try:
            # Get basic DNS records
            dns_analysis["dns_records"] = await self._get_dns_records(domain)
            
            # Extract name servers for further testing
            if "NS" in dns_analysis["dns_records"]:
                dns_analysis["name_servers"] = [
                    str(rdata) for rdata in dns_analysis["dns_records"]["NS"]
                ]
            
            # Extract mail servers
            if "MX" in dns_analysis["dns_records"]:
                dns_analysis["mail_servers"] = [
                    {"priority": rdata.preference, "server": str(rdata.exchange)}
                    for rdata in dns_analysis["dns_records"]["MX"]
                ]
            
            # Test zone transfers
            if test_zone_transfer and dns_analysis["name_servers"]:
                dns_analysis["zone_transfer"] = await self._test_zone_transfers(
                    domain, dns_analysis["name_servers"]
                )
            
            # Enumerate subdomains
            if test_subdomains:
                subdomain_list = self.common_subdomains
                
                # Load custom wordlist if provided
                if wordlist_file:
                    custom_subdomains = await self._load_subdomain_wordlist(wordlist_file)
                    if custom_subdomains:
                        subdomain_list = custom_subdomains
                
                dns_analysis["subdomains"] = await self._enumerate_subdomains(
                    domain, subdomain_list[:50 if self.is_safe_mode else 100]
                )
            
            # Test SRV records
            dns_analysis["srv_records"] = await self._enumerate_srv_records(domain)
            
            # Test DNSSEC
            if test_dnssec:
                dns_analysis["dnssec_info"] = await self._test_dnssec(domain)
            
        except Exception as e:
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": str(e)},
                errors=[str(e)]
            )
        
        # Analyze findings for vulnerabilities
        self._analyze_dns_vulnerabilities(dns_analysis, domain)
        
        self.status = PluginStatus.COMPLETED
        result_data = {
            "target": target,
            **dns_analysis,
            "timestamp": datetime.now().isoformat()
        }
        
        result = PluginResult(
            plugin_name=self.name,
            status=self.status,
            data=result_data,
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(result)
        return result
    
    async def _get_dns_records(self, domain: str) -> Dict:
        """Get various DNS records for a domain"""
        records = {}
        
        for record_type in self.record_types:
            try:
                if self._rate_limiter:
                    async with self._rate_limiter:
                        result = await self._query_dns_record(domain, record_type)
                else:
                    result = await self._query_dns_record(domain, record_type)
                
                if result:
                    records[record_type] = result
                    
            except Exception:
                continue
        
        return records
    
    async def _query_dns_record(self, domain: str, record_type: str) -> Optional[List]:
        """Query a specific DNS record type"""
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self._dns_query_sync,
                domain, record_type
            )
            return result
        except:
            return None
    
    def _dns_query_sync(self, domain: str, record_type: str) -> Optional[List]:
        """Synchronous DNS query"""
        try:
            resolver = dns.resolver.Resolver()
            resolver.timeout = self.dns_timeout
            resolver.lifetime = self.dns_timeout
            
            answers = resolver.resolve(domain, record_type)
            return [rdata for rdata in answers]
            
        except dns.exception.DNSException:
            return None
        except Exception:
            return None
    
    async def _test_zone_transfers(self, domain: str, name_servers: List[str]) -> Dict:
        """Test for DNS zone transfers"""
        zone_transfer_results = {}
        
        for ns in name_servers:
            try:
                if self._rate_limiter:
                    async with self._rate_limiter:
                        result = await self._attempt_zone_transfer(domain, ns)
                else:
                    result = await self._attempt_zone_transfer(domain, ns)
                
                zone_transfer_results[ns] = result
                
            except Exception as e:
                zone_transfer_results[ns] = {"error": str(e), "success": False}
        
        return zone_transfer_results
    
    async def _attempt_zone_transfer(self, domain: str, name_server: str) -> Dict:
        """Attempt zone transfer from a specific name server"""
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self._zone_transfer_sync,
                domain, name_server
            )
            return result
        except Exception as e:
            return {"error": str(e), "success": False}
    
    def _zone_transfer_sync(self, domain: str, name_server: str) -> Dict:
        """Synchronous zone transfer attempt"""
        result = {"success": False, "records": [], "error": None}
        
        try:
            # Resolve name server to IP
            try:
                ns_ip = socket.gethostbyname(name_server.rstrip('.'))
            except:
                ns_ip = name_server
            
            # Attempt zone transfer
            zone = dns.zone.from_xfr(
                dns.query.xfr(ns_ip, domain, timeout=self.dns_timeout)
            )
            
            result["success"] = True
            
            # Extract records from zone
            records = []
            for name, node in zone.nodes.items():
                for rdata in node.rdatasets:
                    records.append({
                        "name": str(name),
                        "type": dns.rdatatype.to_text(rdata.rdtype),
                        "data": [str(rd) for rd in rdata]
                    })
            
            result["records"] = records[:100]  # Limit results
            
        except dns.exception.DNSException as e:
            result["error"] = f"DNS error: {str(e)}"
        except Exception as e:
            result["error"] = f"Connection error: {str(e)}"
        
        return result
    
    async def _enumerate_subdomains(self, domain: str, subdomain_list: List[str]) -> List[Dict]:
        """Enumerate subdomains"""
        found_subdomains = []
        
        # Create tasks for concurrent subdomain testing
        tasks = []
        for subdomain in subdomain_list:
            full_domain = f"{subdomain}.{domain}"
            task = self._test_subdomain(full_domain)
            tasks.append(task)
        
        # Process results
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for i, result in enumerate(results):
            if isinstance(result, dict) and result.get("exists"):
                found_subdomains.append(result)
        
        return found_subdomains
    
    async def _test_subdomain(self, subdomain: str) -> Dict:
        """Test if a subdomain exists"""
        result = {
            "subdomain": subdomain,
            "exists": False,
            "records": {}
        }
        
        try:
            if self._rate_limiter:
                async with self._rate_limiter:
                    records = await self._query_subdomain_records(subdomain)
            else:
                records = await self._query_subdomain_records(subdomain)
            
            if records:
                result["exists"] = True
                result["records"] = records
                
        except Exception:
            pass
        
        return result
    
    async def _query_subdomain_records(self, subdomain: str) -> Dict:
        """Query records for a subdomain"""
        records = {}
        
        # Test A and AAAA records primarily
        for record_type in ['A', 'AAAA', 'CNAME']:
            try:
                loop = asyncio.get_event_loop()
                result = await loop.run_in_executor(
                    None,
                    self._dns_query_sync,
                    subdomain, record_type
                )
                
                if result:
                    records[record_type] = [str(rdata) for rdata in result]
                    
            except Exception:
                continue
        
        return records
    
    async def _enumerate_srv_records(self, domain: str) -> List[Dict]:
        """Enumerate SRV records"""
        srv_records = []
        
        for service in self.srv_services:
            try:
                if self._rate_limiter:
                    async with self._rate_limiter:
                        result = await self._query_srv_record(service, domain)
                else:
                    result = await self._query_srv_record(service, domain)
                
                if result:
                    srv_records.append({
                        "service": service,
                        "records": result
                    })
                    
            except Exception:
                continue
        
        return srv_records
    
    async def _query_srv_record(self, service: str, domain: str) -> Optional[List[Dict]]:
        """Query a specific SRV record"""
        try:
            full_service = f"{service}.{domain}"
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self._dns_query_sync,
                full_service, 'SRV'
            )
            
            if result:
                return [
                    {
                        "priority": rdata.priority,
                        "weight": rdata.weight,
                        "port": rdata.port,
                        "target": str(rdata.target)
                    }
                    for rdata in result
                ]
                
        except Exception:
            pass
        
        return None
    
    async def _test_dnssec(self, domain: str) -> Dict:
        """Test DNSSEC configuration"""
        dnssec_info = {
            "enabled": False,
            "dnskey_records": [],
            "ds_records": [],
            "nsec_records": [],
            "validation_errors": []
        }
        
        try:
            # Check for DNSKEY records
            dnskey_result = await self._query_dns_record(domain, 'DNSKEY')
            if dnskey_result:
                dnssec_info["enabled"] = True
                dnssec_info["dnskey_records"] = [str(rdata) for rdata in dnskey_result]
            
            # Check for DS records
            ds_result = await self._query_dns_record(domain, 'DS')
            if ds_result:
                dnssec_info["ds_records"] = [str(rdata) for rdata in ds_result]
            
            # Check for NSEC records
            nsec_result = await self._query_dns_record(domain, 'NSEC')
            if nsec_result:
                dnssec_info["nsec_records"] = [str(rdata) for rdata in nsec_result]
            
        except Exception as e:
            dnssec_info["validation_errors"].append(str(e))
        
        return dnssec_info
    
    async def _load_subdomain_wordlist(self, wordlist_file: str) -> Optional[List[str]]:
        """Load subdomain wordlist from file"""
        try:
            with open(wordlist_file, 'r') as f:
                subdomains = [line.strip() for line in f if line.strip()]
            return subdomains
        except Exception:
            return None
    
    def _analyze_dns_vulnerabilities(self, dns_analysis: Dict, domain: str):
        """Analyze DNS findings for vulnerabilities"""
        
        # Check for zone transfer vulnerability
        zone_transfers = dns_analysis.get("zone_transfer", {})
        successful_transfers = [ns for ns, result in zone_transfers.items() 
                              if result.get("success", False)]
        
        if successful_transfers:
            vuln = Vulnerability(
                title="DNS Zone Transfer Enabled",
                description=f"DNS zone transfer is enabled on name servers: {', '.join(successful_transfers)}",
                severity=Severity.HIGH,
                affected_component=domain,
                recommendation="Disable DNS zone transfers or restrict to authorized servers",
                evidence={
                    "vulnerable_name_servers": successful_transfers,
                    "zone_transfer_results": {ns: zone_transfers[ns] for ns in successful_transfers}
                }
            )
            self.add_vulnerability(vuln)
        
        # Check for missing DNSSEC
        dnssec_info = dns_analysis.get("dnssec_info", {})
        if not dnssec_info.get("enabled", False):
            vuln = Vulnerability(
                title="DNSSEC Not Implemented",
                description="Domain does not have DNSSEC enabled",
                severity=Severity.MEDIUM,
                affected_component=domain,
                recommendation="Implement DNSSEC to prevent DNS spoofing attacks",
                evidence={
                    "dnssec_enabled": False,
                    "dnssec_info": dnssec_info
                }
            )
            self.add_vulnerability(vuln)
        
        # Check for information disclosure in DNS records
        dns_records = dns_analysis.get("dns_records", {})
        txt_records = dns_records.get("TXT", [])
        
        if txt_records:
            sensitive_txt = []
            for txt in txt_records:
                txt_str = str(txt).lower()
                if any(keyword in txt_str for keyword in ["password", "key", "secret", "token", "admin"]):
                    sensitive_txt.append(str(txt))
            
            if sensitive_txt:
                vuln = Vulnerability(
                    title="Sensitive Information in DNS TXT Records",
                    description="DNS TXT records contain potentially sensitive information",
                    severity=Severity.MEDIUM,
                    affected_component=domain,
                    recommendation="Review and remove sensitive information from DNS TXT records",
                    evidence={
                        "sensitive_txt_records": sensitive_txt,
                        "all_txt_records": [str(txt) for txt in txt_records]
                    }
                )
                self.add_vulnerability(vuln)
        
        # Check for subdomain takeover opportunities
        subdomains = dns_analysis.get("subdomains", [])
        for subdomain_info in subdomains:
            records = subdomain_info.get("records", {})
            cname_records = records.get("CNAME", [])
            
            for cname in cname_records:
                # Check for common subdomain takeover patterns
                if any(service in cname.lower() for service in [
                    "github", "heroku", "wordpress", "tumblr", "shopify",
                    "desk", "campaignmonitor", "unbounce", "statuspage"
                ]):
                    vuln = Vulnerability(
                        title="Potential Subdomain Takeover",
                        description=f"Subdomain {subdomain_info['subdomain']} points to external service: {cname}",
                        severity=Severity.MEDIUM,
                        affected_component=subdomain_info['subdomain'],
                        recommendation="Verify that the external service is still controlled by your organization",
                        evidence={
                            "subdomain": subdomain_info['subdomain'],
                            "cname_target": cname,
                            "records": records
                        }
                    )
                    self.add_vulnerability(vuln)
        
        # Check for DNS cache poisoning indicators
        name_servers = dns_analysis.get("name_servers", [])
        if len(set(name_servers)) < 2:
            vuln = Vulnerability(
                title="Insufficient DNS Redundancy",
                description="Domain has insufficient DNS name server redundancy",
                severity=Severity.LOW,
                affected_component=domain,
                recommendation="Configure multiple geographically distributed DNS servers",
                evidence={
                    "name_servers": name_servers,
                    "unique_name_servers": len(set(name_servers))
                }
            )
            self.add_vulnerability(vuln)