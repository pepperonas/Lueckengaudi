import asyncio
import ftplib
from typing import Dict, Any, List, Tuple, Optional
from datetime import datetime
import socket
import sys
sys.path.append('..')

from core.base_plugin import BasePlugin, PluginResult, PluginStatus, Vulnerability, Severity


class FTPTester(BasePlugin):
    def __init__(self):
        super().__init__(
            name="FTPTester",
            version="1.0.0", 
            description="FTP service security testing and enumeration"
        )
        
        # Common FTP usernames
        self.common_usernames = [
            "anonymous", "ftp", "admin", "administrator", "root", "user",
            "guest", "test", "demo", "public", "backup", "service",
            "ftpuser", "upload", "download", "web", "www", "site"
        ]
        
        # Common FTP passwords
        self.common_passwords = [
            "", "anonymous", "ftp", "guest", "password", "admin", "root",
            "123456", "password123", "admin123", "ftp123", "test", "demo",
            "public", "upload", "download", "backup", "service", "web",
            "www", "site", "welcome", "letmein", "access"
        ]
        
        # Default FTP credentials
        self.default_credentials = [
            ("anonymous", ""),
            ("anonymous", "anonymous"),
            ("anonymous", "guest"),
            ("ftp", ""),
            ("ftp", "ftp"),
            ("admin", "admin"),
            ("admin", "password"),
            ("root", "root"),
            ("root", "password"),
            ("guest", "guest"),
            ("user", "user"),
            ("test", "test"),
            ("demo", "demo"),
            ("backup", "backup"),
            ("service", "service")
        ]
        
        # Sensitive directories to check
        self.sensitive_directories = [
            "/", "/etc", "/home", "/root", "/var", "/tmp", "/usr",
            "/bin", "/sbin", "/boot", "/opt", "/srv", "/mnt",
            "/backup", "/backups", "/data", "/files", "/upload",
            "/uploads", "/download", "/downloads", "/public",
            "/web", "/www", "/htdocs", "/public_html", "/sites",
            "/config", "/conf", "/logs", "/log", "/admin"
        ]
        
        # FTP commands to test
        self.ftp_commands = [
            "SYST", "HELP", "FEAT", "STAT", "PWD", "LIST", "NLST"
        ]
        
        self.ftp_timeout = 10
    
    def validate_options(self, options: Dict[str, Any]) -> bool:
        return "host" in options
    
    async def execute(self, target: str, options: Dict[str, Any]) -> PluginResult:
        self.status = PluginStatus.RUNNING
        
        host = options.get("host", target)
        port = options.get("port", 21)
        username_list = options.get("usernames", self.common_usernames[:10])
        password_list = options.get("passwords", self.common_passwords[:10])
        test_anonymous = options.get("test_anonymous", True)
        enumerate_dirs = options.get("enumerate_dirs", True)
        
        # Respect safe mode
        if self.is_safe_mode:
            username_list = username_list[:5]
            password_list = password_list[:5]
            enumerate_dirs = False
        
        ftp_analysis = {
            "service_info": {},
            "successful_logins": [],
            "failed_attempts": 0,
            "anonymous_access": False,
            "directory_listing": [],
            "writable_directories": [],
            "server_features": [],
            "vulnerabilities": []
        }
        
        try:
            # First check if FTP service is available
            if not await self._check_ftp_service(host, port):
                self.status = PluginStatus.FAILED
                return PluginResult(
                    plugin_name=self.name,
                    status=self.status,
                    data={"error": f"FTP service not available on {host}:{port}"},
                    errors=[f"FTP service not available on {host}:{port}"]
                )
            
            # Get basic FTP service information
            ftp_analysis["service_info"] = await self._get_ftp_info(host, port)
            
            # Test anonymous access first
            if test_anonymous:
                anon_result = await self._test_anonymous_access(host, port)
                if anon_result["success"]:
                    ftp_analysis["anonymous_access"] = True
                    ftp_analysis["successful_logins"].append(anon_result)
                    
                    # If anonymous access works, enumerate directories
                    if enumerate_dirs:
                        dirs = await self._enumerate_directories(host, port, "anonymous", "")
                        ftp_analysis["directory_listing"] = dirs
                        
                        # Test for writable directories
                        writable = await self._test_writable_directories(host, port, "anonymous", "", dirs)
                        ftp_analysis["writable_directories"] = writable
            
            # Test credential bruteforce if anonymous failed or additional testing requested
            if not ftp_analysis["anonymous_access"] or not self.is_safe_mode:
                for username, password in self.default_credentials[:10]:
                    if username == "anonymous" and ftp_analysis["anonymous_access"]:
                        continue  # Skip if already tested
                    
                    result = await self._test_ftp_login(host, port, username, password)
                    if result["success"]:
                        ftp_analysis["successful_logins"].append(result)
                        
                        # Test directory access for successful login
                        if enumerate_dirs and len(ftp_analysis["directory_listing"]) == 0:
                            dirs = await self._enumerate_directories(host, port, username, password)
                            ftp_analysis["directory_listing"] = dirs
                            
                            writable = await self._test_writable_directories(host, port, username, password, dirs)
                            ftp_analysis["writable_directories"] = writable
                        
                        break  # Stop after first successful login
                    else:
                        ftp_analysis["failed_attempts"] += 1
            
            # Get server features
            if ftp_analysis["successful_logins"]:
                login = ftp_analysis["successful_logins"][0]
                features = await self._get_ftp_features(host, port, login["username"], login["password"])
                ftp_analysis["server_features"] = features
            
        except Exception as e:
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": str(e)},
                errors=[str(e)]
            )
        
        # Analyze findings for vulnerabilities
        self._analyze_ftp_vulnerabilities(ftp_analysis, host, port)
        
        self.status = PluginStatus.COMPLETED
        result_data = {
            "target": target,
            "host": host,
            "port": port,
            **ftp_analysis,
            "timestamp": datetime.now().isoformat()
        }
        
        result = PluginResult(
            plugin_name=self.name,
            status=self.status,
            data=result_data,
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(result)
        return result
    
    async def _check_ftp_service(self, host: str, port: int) -> bool:
        """Check if FTP service is available"""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=self.ftp_timeout
            )
            
            # Read FTP banner
            banner = await asyncio.wait_for(reader.read(1024), timeout=5)
            writer.close()
            await writer.wait_closed()
            
            # Check if it looks like FTP (starts with 220)
            return banner.decode('utf-8', errors='ignore').startswith('220')
        except:
            return False
    
    async def _get_ftp_info(self, host: str, port: int) -> Dict:
        """Get basic FTP service information"""
        info = {}
        
        try:
            loop = asyncio.get_event_loop()
            info = await loop.run_in_executor(
                None,
                self._get_ftp_info_sync,
                host, port
            )
        except Exception as e:
            info["error"] = str(e)
        
        return info
    
    def _get_ftp_info_sync(self, host: str, port: int) -> Dict:
        """Synchronous FTP info gathering"""
        info = {}
        
        try:
            ftp = ftplib.FTP()
            ftp.connect(host, port, timeout=self.ftp_timeout)
            
            info["banner"] = ftp.getwelcome()
            
            # Try to get system information
            try:
                syst_response = ftp.sendcmd('SYST')
                info["system"] = syst_response
            except:
                pass
            
            # Try to get help
            try:
                help_response = ftp.sendcmd('HELP')
                info["help"] = help_response
            except:
                pass
            
            ftp.quit()
            
        except Exception as e:
            info["connection_error"] = str(e)
        
        return info
    
    async def _test_anonymous_access(self, host: str, port: int) -> Dict:
        """Test anonymous FTP access"""
        return await self._test_ftp_login(host, port, "anonymous", "")
    
    async def _test_ftp_login(self, host: str, port: int, username: str, password: str) -> Dict:
        """Test FTP login with given credentials"""
        if self._rate_limiter:
            async with self._rate_limiter:
                return await self._perform_ftp_login(host, port, username, password)
        return await self._perform_ftp_login(host, port, username, password)
    
    async def _perform_ftp_login(self, host: str, port: int, username: str, password: str) -> Dict:
        """Perform the actual FTP login test"""
        result = {
            "username": username,
            "password": password,
            "success": False,
            "error": None,
            "current_directory": None,
            "permissions": []
        }
        
        try:
            loop = asyncio.get_event_loop()
            ftp_result = await loop.run_in_executor(
                None,
                self._ftp_login_sync,
                host, port, username, password
            )
            
            result.update(ftp_result)
            
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def _ftp_login_sync(self, host: str, port: int, username: str, password: str) -> Dict:
        """Synchronous FTP login test"""
        result = {
            "success": False,
            "error": None,
            "current_directory": None,
            "permissions": []
        }
        
        try:
            ftp = ftplib.FTP()
            ftp.connect(host, port, timeout=self.ftp_timeout)
            ftp.login(username, password)
            
            result["success"] = True
            
            # Get current directory
            try:
                result["current_directory"] = ftp.pwd()
            except:
                pass
            
            # Test basic permissions
            permissions = []
            
            # Test LIST permission
            try:
                ftp.nlst()
                permissions.append("LIST")
            except:
                pass
            
            # Test CWD permission (try to change to same directory)
            try:
                current_dir = ftp.pwd()
                ftp.cwd(current_dir)
                permissions.append("CWD")
            except:
                pass
            
            # Test STOR permission (try to upload)
            try:
                ftp.storbinary('STOR test_upload.txt', b'test')
                permissions.append("STOR")
                # Try to delete the test file
                try:
                    ftp.delete('test_upload.txt')
                    permissions.append("DELE")
                except:
                    pass
            except:
                pass
            
            # Test MKD permission (try to create directory)
            try:
                ftp.mkd('test_directory')
                permissions.append("MKD")
                # Try to remove the test directory
                try:
                    ftp.rmd('test_directory')
                    permissions.append("RMD")
                except:
                    pass
            except:
                pass
            
            result["permissions"] = permissions
            
            ftp.quit()
            
        except ftplib.error_perm as e:
            result["error"] = f"Permission denied: {str(e)}"
        except ftplib.error_temp as e:
            result["error"] = f"Temporary error: {str(e)}"
        except Exception as e:
            result["error"] = f"Connection error: {str(e)}"
        
        return result
    
    async def _enumerate_directories(self, host: str, port: int, username: str, password: str) -> List[Dict]:
        """Enumerate accessible directories"""
        directories = []
        
        try:
            loop = asyncio.get_event_loop()
            directories = await loop.run_in_executor(
                None,
                self._enumerate_dirs_sync,
                host, port, username, password
            )
        except Exception:
            pass
        
        return directories
    
    def _enumerate_dirs_sync(self, host: str, port: int, username: str, password: str) -> List[Dict]:
        """Synchronous directory enumeration"""
        directories = []
        
        try:
            ftp = ftplib.FTP()
            ftp.connect(host, port, timeout=self.ftp_timeout)
            ftp.login(username, password)
            
            # Start from root directory
            try:
                ftp.cwd('/')
            except:
                pass
            
            # Get current directory listing
            current_dir = ftp.pwd()
            files = []
            
            try:
                ftp.retrlines('LIST', files.append)
                directories.append({
                    "path": current_dir,
                    "files": files,
                    "accessible": True
                })
            except Exception as e:
                directories.append({
                    "path": current_dir,
                    "files": [],
                    "accessible": False,
                    "error": str(e)
                })
            
            # Test access to sensitive directories
            for test_dir in self.sensitive_directories[:10]:  # Limit in safe mode
                try:
                    ftp.cwd(test_dir)
                    files = []
                    try:
                        ftp.retrlines('LIST', files.append)
                        directories.append({
                            "path": test_dir,
                            "files": files,
                            "accessible": True,
                            "sensitive": True
                        })
                    except:
                        directories.append({
                            "path": test_dir,
                            "files": [],
                            "accessible": True,
                            "sensitive": True,
                            "list_error": "Cannot list directory contents"
                        })
                except:
                    directories.append({
                        "path": test_dir,
                        "files": [],
                        "accessible": False,
                        "sensitive": True
                    })
            
            ftp.quit()
            
        except Exception:
            pass
        
        return directories
    
    async def _test_writable_directories(self, host: str, port: int, username: str, password: str, 
                                       directories: List[Dict]) -> List[str]:
        """Test which directories are writable"""
        writable = []
        
        try:
            loop = asyncio.get_event_loop()
            writable = await loop.run_in_executor(
                None,
                self._test_writable_sync,
                host, port, username, password, directories
            )
        except Exception:
            pass
        
        return writable
    
    def _test_writable_sync(self, host: str, port: int, username: str, password: str, 
                          directories: List[Dict]) -> List[str]:
        """Synchronous writable directory test"""
        writable = []
        
        try:
            ftp = ftplib.FTP()
            ftp.connect(host, port, timeout=self.ftp_timeout)
            ftp.login(username, password)
            
            for dir_info in directories:
                if not dir_info.get("accessible", False):
                    continue
                
                path = dir_info["path"]
                
                try:
                    ftp.cwd(path)
                    
                    # Try to create a test file
                    test_filename = f"test_write_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
                    
                    try:
                        # Create a simple test file
                        from io import BytesIO
                        test_data = BytesIO(b"test write access")
                        ftp.storbinary(f'STOR {test_filename}', test_data)
                        
                        # If successful, directory is writable
                        writable.append(path)
                        
                        # Clean up test file
                        try:
                            ftp.delete(test_filename)
                        except:
                            pass
                        
                    except:
                        pass  # Not writable
                    
                except:
                    pass  # Cannot access directory
            
            ftp.quit()
            
        except Exception:
            pass
        
        return writable
    
    async def _get_ftp_features(self, host: str, port: int, username: str, password: str) -> List[str]:
        """Get FTP server features"""
        features = []
        
        try:
            loop = asyncio.get_event_loop()
            features = await loop.run_in_executor(
                None,
                self._get_features_sync,
                host, port, username, password
            )
        except Exception:
            pass
        
        return features
    
    def _get_features_sync(self, host: str, port: int, username: str, password: str) -> List[str]:
        """Synchronous FTP features enumeration"""
        features = []
        
        try:
            ftp = ftplib.FTP()
            ftp.connect(host, port, timeout=self.ftp_timeout)
            ftp.login(username, password)
            
            # Try FEAT command
            try:
                feat_response = ftp.sendcmd('FEAT')
                features.append(f"FEAT: {feat_response}")
            except:
                pass
            
            # Try other commands
            for cmd in self.ftp_commands:
                try:
                    response = ftp.sendcmd(cmd)
                    features.append(f"{cmd}: {response}")
                except:
                    pass
            
            ftp.quit()
            
        except Exception:
            pass
        
        return features
    
    def _analyze_ftp_vulnerabilities(self, ftp_analysis: Dict, host: str, port: int):
        """Analyze FTP findings for vulnerabilities"""
        
        target = f"{host}:{port}"
        
        # Check for anonymous access
        if ftp_analysis["anonymous_access"]:
            severity = Severity.HIGH
            description = "FTP server allows anonymous access"
            
            # Check if anonymous can write
            if any("STOR" in login.get("permissions", []) for login in ftp_analysis["successful_logins"] 
                   if login["username"] == "anonymous"):
                severity = Severity.CRITICAL
                description = "FTP server allows anonymous write access"
            
            vuln = Vulnerability(
                title="Anonymous FTP Access",
                description=description,
                severity=severity,
                affected_component=target,
                recommendation="Disable anonymous FTP access or restrict to read-only",
                evidence={
                    "anonymous_access": True,
                    "successful_logins": ftp_analysis["successful_logins"],
                    "writable_directories": ftp_analysis["writable_directories"]
                }
            )
            self.add_vulnerability(vuln)
        
        # Check for weak credentials
        for login in ftp_analysis["successful_logins"]:
            username = login["username"]
            password = login["password"]
            
            if username != "anonymous":
                if password == "" or password == username:
                    severity = Severity.HIGH
                elif (username, password) in self.default_credentials:
                    severity = Severity.HIGH
                else:
                    severity = Severity.MEDIUM
                
                vuln = Vulnerability(
                    title="Weak FTP Credentials",
                    description=f"FTP server allows login with weak credentials: {username}:{password}",
                    severity=severity,
                    affected_component=target,
                    recommendation="Use strong passwords and implement account lockout policies",
                    evidence={
                        "username": username,
                        "password": password,
                        "permissions": login.get("permissions", []),
                        "current_directory": login.get("current_directory")
                    }
                )
                self.add_vulnerability(vuln)
        
        # Check for writable directories
        if ftp_analysis["writable_directories"]:
            vuln = Vulnerability(
                title="FTP Writable Directories",
                description=f"FTP server has writable directories: {', '.join(ftp_analysis['writable_directories'])}",
                severity=Severity.MEDIUM,
                affected_component=target,
                recommendation="Restrict write permissions to necessary directories only",
                evidence={
                    "writable_directories": ftp_analysis["writable_directories"],
                    "directory_listing": ftp_analysis["directory_listing"]
                }
            )
            self.add_vulnerability(vuln)
        
        # Check for sensitive directory access
        sensitive_accessible = [d for d in ftp_analysis["directory_listing"] 
                              if d.get("sensitive", False) and d.get("accessible", False)]
        
        if sensitive_accessible:
            vuln = Vulnerability(
                title="Sensitive Directory Access",
                description=f"FTP server allows access to sensitive directories",
                severity=Severity.MEDIUM,
                affected_component=target,
                recommendation="Restrict access to sensitive system directories",
                evidence={
                    "sensitive_directories": [d["path"] for d in sensitive_accessible],
                    "directory_details": sensitive_accessible
                }
            )
            self.add_vulnerability(vuln)
        
        # Check for information disclosure in banner
        service_info = ftp_analysis.get("service_info", {})
        banner = service_info.get("banner", "")
        
        if banner and any(version_info in banner.lower() 
                         for version_info in ["version", "vsftpd", "proftpd", "pureftpd"]):
            vuln = Vulnerability(
                title="FTP Banner Information Disclosure",
                description="FTP server banner reveals version information",
                severity=Severity.LOW,
                affected_component=target,
                recommendation="Configure FTP server to hide version information in banner",
                evidence={
                    "banner": banner,
                    "service_info": service_info
                }
            )
            self.add_vulnerability(vuln)