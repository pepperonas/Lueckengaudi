import asyncio
import socket
import struct
import ipaddress
from typing import Dict, Any, List, Tuple, Optional
from datetime import datetime
import sys
sys.path.append('..')

from core.base_plugin import BasePlugin, PluginResult, PluginStatus, Vulnerability, Severity


class NetworkMapper(BasePlugin):
    def __init__(self):
        super().__init__(
            name="NetworkMapper",
            version="1.0.0",
            description="Network topology discovery and mapping"
        )
        
        # Common ports for host discovery
        self.discovery_ports = [
            22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 1723, 3389, 5900
        ]
        
        # Network protocols for discovery
        self.discovery_methods = {
            "tcp_syn": {"description": "TCP SYN scan", "ports": [80, 443, 22, 23]},
            "tcp_connect": {"description": "TCP Connect scan", "ports": [80, 443, 22, 25]},
            "icmp_ping": {"description": "ICMP ping sweep", "ports": []},
            "arp_scan": {"description": "ARP scan (local network)", "ports": []}
        }
        
        # Common network services for topology mapping
        self.topology_services = {
            22: "SSH",
            23: "Telnet", 
            25: "SMTP",
            53: "DNS",
            80: "HTTP",
            135: "RPC",
            139: "NetBIOS",
            143: "IMAP",
            443: "HTTPS",
            445: "SMB",
            993: "IMAPS",
            995: "POP3S",
            1723: "PPTP",
            3389: "RDP",
            5900: "VNC"
        }
        
        # Network device indicators
        self.device_indicators = {
            "router": ["cisco", "juniper", "mikrotik", "pfsense", "openwrt", "dd-wrt"],
            "switch": ["cisco", "hp", "dell", "netgear", "d-link"],
            "firewall": ["checkpoint", "palo alto", "fortinet", "sophos", "watchguard"],
            "printer": ["hp", "canon", "epson", "xerox", "brother"],
            "nas": ["synology", "qnap", "buffalo", "netgear"],
            "camera": ["axis", "hikvision", "dahua", "foscam"],
            "access_point": ["ubiquiti", "cisco", "aruba", "ruckus"]
        }
        
        self.scan_timeout = 2
        self.max_concurrent = 50
    
    def validate_options(self, options: Dict[str, Any]) -> bool:
        return "network" in options or "hosts" in options
    
    async def execute(self, target: str, options: Dict[str, Any]) -> PluginResult:
        self.status = PluginStatus.RUNNING
        
        network = options.get("network", None)
        hosts = options.get("hosts", [])
        discovery_method = options.get("method", "tcp_connect")
        max_hosts = options.get("max_hosts", 100)
        port_scan = options.get("port_scan", True)
        service_detection = options.get("service_detection", True)
        topology_mapping = options.get("topology_mapping", True)
        
        # Respect safe mode
        if self.is_safe_mode:
            max_hosts = min(max_hosts, 20)
            discovery_method = "tcp_connect"  # Use less aggressive method
            port_scan = False
        
        network_map = {
            "scan_info": {
                "network": network,
                "method": discovery_method,
                "timestamp": datetime.now().isoformat()
            },
            "discovered_hosts": [],
            "network_topology": {},
            "device_classification": {},
            "network_services": {},
            "network_segments": []
        }
        
        try:
            # Determine target hosts
            target_hosts = []
            
            if network:
                target_hosts = await self._generate_host_list(network, max_hosts)
            elif hosts:
                target_hosts = hosts[:max_hosts]
            else:
                # Use target as single host
                target_hosts = [target]
            
            if not target_hosts:
                self.status = PluginStatus.FAILED
                return PluginResult(
                    plugin_name=self.name,
                    status=self.status,
                    data={"error": "No target hosts specified"},
                    errors=["No target hosts specified"]
                )
            
            # Discover live hosts
            network_map["discovered_hosts"] = await self._discover_hosts(
                target_hosts, discovery_method
            )
            
            live_hosts = [host for host in network_map["discovered_hosts"] if host.get("alive", False)]
            
            # Port scanning and service detection
            if port_scan and live_hosts:
                network_map["network_services"] = await self._scan_services(
                    [host["ip"] for host in live_hosts], service_detection
                )
            
            # Device classification
            if live_hosts:
                network_map["device_classification"] = await self._classify_devices(live_hosts)
            
            # Topology mapping
            if topology_mapping and live_hosts:
                network_map["network_topology"] = await self._map_topology(live_hosts)
            
            # Network segmentation analysis
            if len(live_hosts) > 1:
                network_map["network_segments"] = self._analyze_network_segments(live_hosts)
            
        except Exception as e:
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": str(e)},
                errors=[str(e)]
            )
        
        # Analyze findings for vulnerabilities
        self._analyze_network_vulnerabilities(network_map)
        
        self.status = PluginStatus.COMPLETED
        result_data = {
            "target": target,
            **network_map,
            "total_hosts_scanned": len(target_hosts),
            "live_hosts_found": len([h for h in network_map["discovered_hosts"] if h.get("alive", False)]),
            "timestamp": datetime.now().isoformat()
        }
        
        result = PluginResult(
            plugin_name=self.name,
            status=self.status,
            data=result_data,
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(result)
        return result
    
    async def _generate_host_list(self, network: str, max_hosts: int) -> List[str]:
        """Generate list of hosts from network CIDR"""
        try:
            network_obj = ipaddress.ip_network(network, strict=False)
            hosts = []
            
            for i, host in enumerate(network_obj.hosts()):
                if i >= max_hosts:
                    break
                hosts.append(str(host))
            
            return hosts
            
        except Exception:
            return []
    
    async def _discover_hosts(self, hosts: List[str], method: str) -> List[Dict]:
        """Discover live hosts using specified method"""
        discovered = []
        semaphore = asyncio.Semaphore(self.max_concurrent)
        
        tasks = []
        for host in hosts:
            task = self._test_host_alive(semaphore, host, method)
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for result in results:
            if isinstance(result, dict):
                discovered.append(result)
        
        return discovered
    
    async def _test_host_alive(self, semaphore: asyncio.Semaphore, host: str, method: str) -> Dict:
        """Test if a host is alive using specified method"""
        async with semaphore:
            if self._rate_limiter:
                async with self._rate_limiter:
                    return await self._perform_host_discovery(host, method)
            return await self._perform_host_discovery(host, method)
    
    async def _perform_host_discovery(self, host: str, method: str) -> Dict:
        """Perform host discovery using specified method"""
        result = {
            "ip": host,
            "alive": False,
            "method": method,
            "response_time": None,
            "open_ports": []
        }
        
        try:
            if method == "icmp_ping":
                alive, response_time = await self._icmp_ping(host)
                result["alive"] = alive
                result["response_time"] = response_time
                
            elif method in ["tcp_syn", "tcp_connect"]:
                # Use TCP port testing for host discovery
                test_ports = self.discovery_methods[method]["ports"]
                open_ports = []
                
                for port in test_ports:
                    if await self._test_tcp_port(host, port):
                        open_ports.append(port)
                
                result["alive"] = len(open_ports) > 0
                result["open_ports"] = open_ports
                
            elif method == "arp_scan":
                # ARP scan (simplified - would need raw sockets for real ARP)
                alive, response_time = await self._tcp_ping(host, 80)
                result["alive"] = alive
                result["response_time"] = response_time
            
            # Try to resolve hostname
            if result["alive"]:
                try:
                    hostname = socket.gethostbyaddr(host)[0]
                    result["hostname"] = hostname
                except:
                    result["hostname"] = None
            
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    async def _icmp_ping(self, host: str) -> Tuple[bool, Optional[float]]:
        """Perform ICMP ping"""
        try:
            start_time = datetime.now()
            
            proc = await asyncio.create_subprocess_exec(
                'ping', '-c', '1', '-W', str(int(self.scan_timeout * 1000)), host,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            await asyncio.wait_for(proc.communicate(), timeout=self.scan_timeout + 1)
            
            end_time = datetime.now()
            response_time = (end_time - start_time).total_seconds() * 1000
            
            return proc.returncode == 0, response_time
            
        except Exception:
            return False, None
    
    async def _tcp_ping(self, host: str, port: int) -> Tuple[bool, Optional[float]]:
        """Perform TCP ping to a specific port"""
        try:
            start_time = datetime.now()
            
            _, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=self.scan_timeout
            )
            
            end_time = datetime.now()
            response_time = (end_time - start_time).total_seconds() * 1000
            
            writer.close()
            await writer.wait_closed()
            
            return True, response_time
            
        except Exception:
            return False, None
    
    async def _test_tcp_port(self, host: str, port: int) -> bool:
        """Test if TCP port is open"""
        try:
            _, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=self.scan_timeout
            )
            
            writer.close()
            await writer.wait_closed()
            return True
            
        except Exception:
            return False
    
    async def _scan_services(self, hosts: List[str], service_detection: bool) -> Dict:
        """Scan services on discovered hosts"""
        services = {}
        
        for host in hosts:
            host_services = {}
            
            # Scan common ports
            ports_to_scan = self.discovery_ports if not self.is_safe_mode else self.discovery_ports[:8]
            
            for port in ports_to_scan:
                try:
                    if await self._test_tcp_port(host, port):
                        service_info = {
                            "port": port,
                            "state": "open",
                            "service": self.topology_services.get(port, "unknown")
                        }
                        
                        # Service detection
                        if service_detection:
                            banner = await self._grab_service_banner(host, port)
                            if banner:
                                service_info["banner"] = banner
                                service_info["version_info"] = self._extract_version_info(banner)
                        
                        host_services[port] = service_info
                        
                except Exception:
                    continue
            
            if host_services:
                services[host] = host_services
        
        return services
    
    async def _grab_service_banner(self, host: str, port: int) -> Optional[str]:
        """Grab service banner"""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=self.scan_timeout
            )
            
            # Send appropriate probe based on port
            if port == 80:
                writer.write(b"GET / HTTP/1.0\r\n\r\n")
            elif port == 443:
                writer.write(b"GET / HTTP/1.0\r\n\r\n")
            elif port == 25:
                writer.write(b"EHLO test\r\n")
            else:
                writer.write(b"\r\n")
            
            await writer.drain()
            
            banner = await asyncio.wait_for(reader.read(512), timeout=2)
            
            writer.close()
            await writer.wait_closed()
            
            return banner.decode('utf-8', errors='ignore').strip()
            
        except Exception:
            return None
    
    def _extract_version_info(self, banner: str) -> Dict:
        """Extract version information from banner"""
        version_info = {}
        banner_lower = banner.lower()
        
        # Common software patterns
        software_patterns = {
            "apache": r"apache/([0-9.]+)",
            "nginx": r"nginx/([0-9.]+)",
            "iis": r"microsoft-iis/([0-9.]+)",
            "openssh": r"openssh_([0-9.]+)",
            "postfix": r"postfix \(([^)]+)\)",
            "sendmail": r"sendmail ([0-9.]+)"
        }
        
        import re
        for software, pattern in software_patterns.items():
            match = re.search(pattern, banner_lower)
            if match:
                version_info["software"] = software
                version_info["version"] = match.group(1)
                break
        
        return version_info
    
    async def _classify_devices(self, hosts: List[Dict]) -> Dict:
        """Classify discovered devices based on characteristics"""
        device_classification = {}
        
        for host in hosts:
            host_ip = host["ip"]
            hostname = host.get("hostname", "")
            open_ports = host.get("open_ports", [])
            
            device_type = "unknown"
            confidence = 0
            indicators = []
            
            # Classify based on hostname
            hostname_lower = hostname.lower() if hostname else ""
            for device_class, keywords in self.device_indicators.items():
                for keyword in keywords:
                    if keyword in hostname_lower:
                        device_type = device_class
                        confidence += 30
                        indicators.append(f"hostname contains '{keyword}'")
            
            # Classify based on open ports
            if 3389 in open_ports:  # RDP
                device_type = "windows_server"
                confidence += 40
                indicators.append("RDP port open")
            elif 22 in open_ports and 80 in open_ports:  # SSH + HTTP
                device_type = "linux_server"
                confidence += 30
                indicators.append("SSH and HTTP ports open")
            elif 139 in open_ports or 445 in open_ports:  # SMB
                if device_type == "unknown":
                    device_type = "windows_system"
                confidence += 25
                indicators.append("SMB ports open")
            elif 53 in open_ports:  # DNS
                device_type = "dns_server"
                confidence += 35
                indicators.append("DNS port open")
            elif 80 in open_ports or 443 in open_ports:  # HTTP/HTTPS only
                device_type = "web_server"
                confidence += 20
                indicators.append("Web server ports open")
            
            # Network infrastructure detection
            if any(port in open_ports for port in [161, 162]):  # SNMP
                device_type = "network_device"
                confidence += 40
                indicators.append("SNMP ports open")
            
            device_classification[host_ip] = {
                "device_type": device_type,
                "confidence": min(confidence, 100),
                "indicators": indicators,
                "hostname": hostname,
                "open_ports": open_ports
            }
        
        return device_classification
    
    async def _map_topology(self, hosts: List[Dict]) -> Dict:
        """Map network topology"""
        topology = {
            "network_segments": [],
            "routing_info": {},
            "network_devices": [],
            "connectivity_matrix": {}
        }
        
        # Simple topology mapping based on IP ranges and services
        host_ips = [host["ip"] for host in hosts]
        
        # Group hosts by subnet
        subnets = {}
        for host in hosts:
            ip = ipaddress.ip_address(host["ip"])
            # Assume /24 subnet for simplicity
            subnet = ipaddress.ip_network(f"{ip}/24", strict=False)
            subnet_str = str(subnet.network_address)
            
            if subnet_str not in subnets:
                subnets[subnet_str] = []
            subnets[subnet_str].append(host)
        
        topology["network_segments"] = [
            {
                "subnet": subnet,
                "hosts": len(hosts),
                "host_list": [h["ip"] for h in hosts]
            }
            for subnet, hosts in subnets.items()
        ]
        
        # Identify potential network devices
        for host in hosts:
            open_ports = host.get("open_ports", [])
            hostname = host.get("hostname", "")
            
            if any(port in open_ports for port in [22, 23, 80, 443, 161]):
                device_score = 0
                
                # Check for management interfaces
                if 80 in open_ports or 443 in open_ports:
                    device_score += 20
                if 22 in open_ports or 23 in open_ports:
                    device_score += 30
                if 161 in open_ports:  # SNMP
                    device_score += 50
                
                # Check hostname patterns
                if hostname and any(pattern in hostname.lower() 
                                  for pattern in ["router", "switch", "fw", "firewall", "gw", "gateway"]):
                    device_score += 40
                
                if device_score >= 30:
                    topology["network_devices"].append({
                        "ip": host["ip"],
                        "hostname": hostname,
                        "device_score": device_score,
                        "open_ports": open_ports
                    })
        
        return topology
    
    def _analyze_network_segments(self, hosts: List[Dict]) -> List[Dict]:
        """Analyze network segmentation"""
        segments = []
        
        # Group hosts by IP range
        ip_groups = {}
        for host in hosts:
            ip = ipaddress.ip_address(host["ip"])
            network = ipaddress.ip_network(f"{ip}/24", strict=False)
            network_str = str(network)
            
            if network_str not in ip_groups:
                ip_groups[network_str] = []
            ip_groups[network_str].append(host)
        
        for network, network_hosts in ip_groups.items():
            # Analyze services in this segment
            services = set()
            device_types = set()
            
            for host in network_hosts:
                open_ports = host.get("open_ports", [])
                for port in open_ports:
                    if port in self.topology_services:
                        services.add(self.topology_services[port])
                
                # Determine device type based on ports
                if 3389 in open_ports:
                    device_types.add("windows")
                elif 22 in open_ports:
                    device_types.add("linux")
                elif 139 in open_ports or 445 in open_ports:
                    device_types.add("windows")
            
            segment_info = {
                "network": network,
                "host_count": len(network_hosts),
                "services": list(services),
                "device_types": list(device_types),
                "security_concerns": []
            }
            
            # Identify security concerns
            if "SMB" in services:
                segment_info["security_concerns"].append("SMB services detected")
            if "Telnet" in services:
                segment_info["security_concerns"].append("Insecure Telnet detected")
            if len(services) > 10:
                segment_info["security_concerns"].append("Many services exposed")
            
            segments.append(segment_info)
        
        return segments
    
    def _analyze_network_vulnerabilities(self, network_map: Dict):
        """Analyze network mapping results for vulnerabilities"""
        
        discovered_hosts = network_map.get("discovered_hosts", [])
        live_hosts = [h for h in discovered_hosts if h.get("alive", False)]
        
        # Check for network reconnaissance exposure
        if len(live_hosts) > 0:
            vuln = Vulnerability(
                title="Network Hosts Discoverable",
                description=f"Network scan discovered {len(live_hosts)} live hosts, indicating network is accessible for reconnaissance",
                severity=Severity.INFO,
                affected_component="Network Infrastructure",
                recommendation="Implement network segmentation and host-based firewalls to limit discoverability",
                evidence={
                    "total_hosts_scanned": len(discovered_hosts),
                    "live_hosts_found": len(live_hosts),
                    "discovery_methods": network_map.get("scan_info", {}).get("method", "unknown")
                }
            )
            self.add_vulnerability(vuln)
        
        # Check for insecure services
        network_services = network_map.get("network_services", {})
        insecure_services = []
        
        for host, services in network_services.items():
            for port, service_info in services.items():
                service_name = service_info.get("service", "").lower()
                
                if service_name in ["telnet", "ftp", "http"]:
                    insecure_services.append(f"{host}:{port} ({service_name})")
        
        if insecure_services:
            vuln = Vulnerability(
                title="Insecure Network Services Detected",
                description=f"Insecure services detected: {', '.join(insecure_services[:5])}",
                severity=Severity.MEDIUM,
                affected_component="Network Services",
                recommendation="Replace insecure services with secure alternatives (SSH, SFTP, HTTPS)",
                evidence={
                    "insecure_services": insecure_services,
                    "affected_hosts": len(set(svc.split(':')[0] for svc in insecure_services))
                }
            )
            self.add_vulnerability(vuln)
        
        # Check for network device exposure
        topology = network_map.get("network_topology", {})
        network_devices = topology.get("network_devices", [])
        
        if network_devices:
            exposed_devices = []
            for device in network_devices:
                if 80 in device.get("open_ports", []) or 443 in device.get("open_ports", []):
                    exposed_devices.append(device["ip"])
            
            if exposed_devices:
                vuln = Vulnerability(
                    title="Network Infrastructure Management Interfaces Exposed",
                    description=f"Network devices with web management interfaces detected: {', '.join(exposed_devices)}",
                    severity=Severity.MEDIUM,
                    affected_component="Network Infrastructure",
                    recommendation="Restrict access to management interfaces and use VPN or dedicated management networks",
                    evidence={
                        "exposed_devices": exposed_devices,
                        "device_details": network_devices
                    }
                )
                self.add_vulnerability(vuln)
        
        # Check for poor network segmentation
        segments = network_map.get("network_segments", [])
        if len(segments) == 1 and len(live_hosts) > 10:
            vuln = Vulnerability(
                title="Poor Network Segmentation",
                description="All discovered hosts appear to be in a single network segment",
                severity=Severity.LOW,
                affected_component="Network Architecture",
                recommendation="Implement network segmentation to isolate different types of systems and services",
                evidence={
                    "network_segments": len(segments),
                    "total_hosts": len(live_hosts),
                    "segment_details": segments
                }
            )
            self.add_vulnerability(vuln)