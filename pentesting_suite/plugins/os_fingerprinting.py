import asyncio
import socket
import struct
import random
from typing import Dict, Any, List, Tuple, Optional
from datetime import datetime
import sys
sys.path.append('..')

from core.base_plugin import BasePlugin, PluginResult, PluginStatus, Vulnerability, Severity


class OSFingerprinting(BasePlugin):
    def __init__(self):
        super().__init__(
            name="OSFingerprinting",
            version="1.0.0",
            description="Operating System detection and fingerprinting"
        )
        
        # TCP flag combinations for OS detection
        self.tcp_tests = {
            "syn": {"flags": 0x02, "description": "SYN packet"},
            "syn_ack": {"flags": 0x12, "description": "SYN+ACK packet"},
            "fin": {"flags": 0x01, "description": "FIN packet"},
            "null": {"flags": 0x00, "description": "NULL packet"},
            "xmas": {"flags": 0x29, "description": "XMAS packet (FIN+PSH+URG)"},
            "ack": {"flags": 0x10, "description": "ACK packet"},
            "window": {"flags": 0x10, "description": "Window scale test"},
            "maimon": {"flags": 0x11, "description": "Maimon test (FIN+ACK)"}
        }
        
        # ICMP tests for OS detection
        self.icmp_tests = {
            "echo_request": {"type": 8, "code": 0, "description": "ICMP Echo Request"},
            "timestamp": {"type": 13, "code": 0, "description": "ICMP Timestamp"},
            "info_request": {"type": 15, "code": 0, "description": "ICMP Info Request"},
            "netmask_request": {"type": 17, "code": 0, "description": "ICMP Netmask Request"}
        }
        
        # UDP tests
        self.udp_tests = {
            "closed_port": {"description": "UDP packet to closed port"},
            "open_port": {"description": "UDP packet to open port"}
        }
        
        # OS signatures based on responses
        self.os_signatures = {
            "linux": {
                "tcp_window_size": [5840, 65535],
                "tcp_options": ["mss", "sackOK", "timestamp", "nop", "wscale"],
                "ttl_range": [64, 64],
                "icmp_responses": ["echo_reply"],
                "tcp_seq_predictability": "low"
            },
            "windows": {
                "tcp_window_size": [8192, 65535],
                "tcp_options": ["mss", "nop", "wscale", "sackOK"],
                "ttl_range": [128, 128],
                "icmp_responses": ["echo_reply", "timestamp_reply"],
                "tcp_seq_predictability": "medium"
            },
            "freebsd": {
                "tcp_window_size": [65535, 65535],
                "tcp_options": ["mss", "nop", "wscale", "sackOK", "timestamp"],
                "ttl_range": [64, 64],
                "icmp_responses": ["echo_reply"],
                "tcp_seq_predictability": "low"
            },
            "macos": {
                "tcp_window_size": [65535, 65535],
                "tcp_options": ["mss", "nop", "wscale", "sackOK", "timestamp"],
                "ttl_range": [64, 64],
                "icmp_responses": ["echo_reply"],
                "tcp_seq_predictability": "low"
            },
            "cisco": {
                "tcp_window_size": [4128, 4128],
                "tcp_options": ["mss"],
                "ttl_range": [255, 255],
                "icmp_responses": ["echo_reply"],
                "tcp_seq_predictability": "high"
            }
        }
        
        # Service banners that help identify OS
        self.service_banners = {
            "ssh": {
                "linux": ["OpenSSH", "Ubuntu", "Debian", "CentOS", "RHEL"],
                "windows": ["Microsoft", "Windows"],
                "cisco": ["Cisco"],
                "freebsd": ["FreeBSD"],
                "macos": ["Darwin"]
            },
            "ftp": {
                "linux": ["vsftpd", "ProFTPD"],
                "windows": ["Microsoft FTP", "IIS"],
                "freebsd": ["FreeBSD ftpd"]
            },
            "http": {
                "linux": ["Apache", "nginx"],
                "windows": ["Microsoft-IIS", "Microsoft-HTTPAPI"],
                "freebsd": ["Apache"]
            }
        }
        
        self.timeout = 3
    
    def validate_options(self, options: Dict[str, Any]) -> bool:
        return "host" in options
    
    async def execute(self, target: str, options: Dict[str, Any]) -> PluginResult:
        self.status = PluginStatus.RUNNING
        
        host = options.get("host", target)
        test_ports = options.get("ports", [22, 23, 25, 53, 80, 110, 143, 443, 993, 995])
        enable_tcp_tests = options.get("tcp_tests", True)
        enable_icmp_tests = options.get("icmp_tests", True)
        enable_service_detection = options.get("service_detection", True)
        
        # Respect safe mode - limit aggressive fingerprinting
        if self.is_safe_mode:
            enable_icmp_tests = False
            test_ports = test_ports[:5]  # Limit port testing
        
        fingerprint_results = {
            "tcp_fingerprint": {},
            "icmp_fingerprint": {},
            "service_banners": {},
            "os_detection": {},
            "confidence_scores": {}
        }
        
        try:
            # TCP-based fingerprinting
            if enable_tcp_tests:
                fingerprint_results["tcp_fingerprint"] = await self._tcp_fingerprinting(host, test_ports)
            
            # ICMP-based fingerprinting
            if enable_icmp_tests:
                fingerprint_results["icmp_fingerprint"] = await self._icmp_fingerprinting(host)
            
            # Service banner detection
            if enable_service_detection:
                fingerprint_results["service_banners"] = await self._service_banner_detection(host, test_ports)
            
            # Analyze results and determine OS
            fingerprint_results["os_detection"] = self._analyze_fingerprints(fingerprint_results)
            
            # Calculate confidence scores
            fingerprint_results["confidence_scores"] = self._calculate_confidence(fingerprint_results)
            
        except Exception as e:
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": str(e)},
                errors=[str(e)]
            )
        
        # Analyze for security implications
        self._analyze_os_vulnerabilities(fingerprint_results, host)
        
        self.status = PluginStatus.COMPLETED
        result_data = {
            "target": target,
            "host": host,
            **fingerprint_results,
            "timestamp": datetime.now().isoformat()
        }
        
        result = PluginResult(
            plugin_name=self.name,
            status=self.status,
            data=result_data,
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(result)
        return result
    
    async def _tcp_fingerprinting(self, host: str, ports: List[int]) -> Dict:
        """Perform TCP-based OS fingerprinting"""
        tcp_results = {}
        
        # Test a few representative ports
        test_ports = ports[:3]  # Limit to avoid overwhelming target
        
        for port in test_ports:
            port_results = {}
            
            for test_name, test_config in self.tcp_tests.items():
                try:
                    if self._rate_limiter:
                        async with self._rate_limiter:
                            result = await self._tcp_test(host, port, test_config)
                    else:
                        result = await self._tcp_test(host, port, test_config)
                    
                    if result:
                        port_results[test_name] = result
                        
                except Exception:
                    continue
            
            if port_results:
                tcp_results[port] = port_results
        
        return tcp_results
    
    async def _tcp_test(self, host: str, port: int, test_config: Dict) -> Optional[Dict]:
        """Perform individual TCP test"""
        try:
            # Create raw socket for TCP testing (simplified version)
            # In practice, this would require root privileges for raw sockets
            # Using regular socket connection as alternative
            
            result = await self._tcp_connect_test(host, port)
            if result:
                result["test_type"] = test_config["description"]
                return result
                
        except Exception:
            pass
        
        return None
    
    async def _tcp_connect_test(self, host: str, port: int) -> Optional[Dict]:
        """Simplified TCP connection test"""
        try:
            start_time = datetime.now()
            
            _, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=self.timeout
            )
            
            end_time = datetime.now()
            response_time = (end_time - start_time).total_seconds() * 1000
            
            # Get socket info
            sock = writer.get_extra_info('socket')
            if sock:
                # Get TCP window size from socket options
                try:
                    window_size = sock.getsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF)
                except:
                    window_size = None
                
                writer.close()
                await writer.wait_closed()
                
                return {
                    "connected": True,
                    "response_time_ms": response_time,
                    "window_size": window_size,
                    "port": port
                }
            
        except asyncio.TimeoutError:
            return {"connected": False, "timeout": True, "port": port}
        except ConnectionRefusedError:
            return {"connected": False, "refused": True, "port": port}
        except Exception as e:
            return {"connected": False, "error": str(e), "port": port}
        
        return None
    
    async def _icmp_fingerprinting(self, host: str) -> Dict:
        """Perform ICMP-based OS fingerprinting"""
        icmp_results = {}
        
        for test_name, test_config in self.icmp_tests.items():
            try:
                if self._rate_limiter:
                    async with self._rate_limiter:
                        result = await self._icmp_test(host, test_config)
                else:
                    result = await self._icmp_test(host, test_config)
                
                if result:
                    icmp_results[test_name] = result
                    
            except Exception:
                continue
        
        return icmp_results
    
    async def _icmp_test(self, host: str, test_config: Dict) -> Optional[Dict]:
        """Perform individual ICMP test"""
        try:
            # Simplified ICMP test using ping
            # Real implementation would use raw ICMP sockets
            
            start_time = datetime.now()
            
            # Use system ping as alternative to raw ICMP
            proc = await asyncio.create_subprocess_exec(
                'ping', '-c', '1', '-W', str(int(self.timeout * 1000)), host,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=self.timeout + 1)
            
            end_time = datetime.now()
            response_time = (end_time - start_time).total_seconds() * 1000
            
            if proc.returncode == 0:
                # Parse ping output for TTL and other info
                output = stdout.decode('utf-8', errors='ignore')
                ttl = self._extract_ttl_from_ping(output)
                
                return {
                    "success": True,
                    "response_time_ms": response_time,
                    "ttl": ttl,
                    "test_type": test_config["description"]
                }
            else:
                return {
                    "success": False,
                    "error": stderr.decode('utf-8', errors='ignore'),
                    "test_type": test_config["description"]
                }
                
        except Exception as e:
            return {"success": False, "error": str(e), "test_type": test_config["description"]}
    
    def _extract_ttl_from_ping(self, ping_output: str) -> Optional[int]:
        """Extract TTL value from ping output"""
        try:
            # Look for TTL in ping output
            import re
            ttl_match = re.search(r'ttl=(\d+)', ping_output, re.IGNORECASE)
            if ttl_match:
                return int(ttl_match.group(1))
        except:
            pass
        
        return None
    
    async def _service_banner_detection(self, host: str, ports: List[int]) -> Dict:
        """Detect service banners to help with OS identification"""
        banners = {}
        
        # Common services that provide useful banners
        service_ports = {
            22: "ssh",
            21: "ftp", 
            25: "smtp",
            80: "http",
            110: "pop3",
            143: "imap",
            443: "https"
        }
        
        for port in ports:
            if port in service_ports:
                service = service_ports[port]
                
                try:
                    if self._rate_limiter:
                        async with self._rate_limiter:
                            banner = await self._grab_banner(host, port, service)
                    else:
                        banner = await self._grab_banner(host, port, service)
                    
                    if banner:
                        banners[port] = {
                            "service": service,
                            "banner": banner,
                            "os_hints": self._analyze_banner_for_os(banner, service)
                        }
                        
                except Exception:
                    continue
        
        return banners
    
    async def _grab_banner(self, host: str, port: int, service: str) -> Optional[str]:
        """Grab service banner"""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=self.timeout
            )
            
            # Send appropriate request based on service
            if service == "http":
                writer.write(b"GET / HTTP/1.0\r\n\r\n")
            elif service == "https":
                # For HTTPS, we'd need SSL context
                writer.write(b"GET / HTTP/1.0\r\n\r\n")
            elif service == "smtp":
                writer.write(b"EHLO test\r\n")
            elif service == "ftp":
                pass  # FTP sends banner automatically
            elif service == "ssh":
                pass  # SSH sends banner automatically
            else:
                writer.write(b"\r\n")
            
            await writer.drain()
            
            # Read response
            banner = await asyncio.wait_for(reader.read(1024), timeout=self.timeout)
            
            writer.close()
            await writer.wait_closed()
            
            return banner.decode('utf-8', errors='ignore').strip()
            
        except Exception:
            return None
    
    def _analyze_banner_for_os(self, banner: str, service: str) -> List[str]:
        """Analyze banner for OS hints"""
        os_hints = []
        banner_lower = banner.lower()
        
        if service in self.service_banners:
            for os_name, indicators in self.service_banners[service].items():
                for indicator in indicators:
                    if indicator.lower() in banner_lower:
                        os_hints.append(os_name)
        
        # Additional generic OS indicators
        if any(indicator in banner_lower for indicator in ["ubuntu", "debian", "centos", "rhel", "linux"]):
            os_hints.append("linux")
        elif any(indicator in banner_lower for indicator in ["windows", "microsoft", "win32"]):
            os_hints.append("windows")
        elif "freebsd" in banner_lower:
            os_hints.append("freebsd")
        elif any(indicator in banner_lower for indicator in ["darwin", "macos", "mac os"]):
            os_hints.append("macos")
        elif "cisco" in banner_lower:
            os_hints.append("cisco")
        
        return list(set(os_hints))  # Remove duplicates
    
    def _analyze_fingerprints(self, fingerprint_results: Dict) -> Dict:
        """Analyze all fingerprint data to determine OS"""
        os_scores = {}
        
        # Analyze TCP fingerprints
        tcp_data = fingerprint_results.get("tcp_fingerprint", {})
        for port, results in tcp_data.items():
            for test, data in results.items():
                if data.get("connected"):
                    # Analyze window size, timing, etc.
                    window_size = data.get("window_size")
                    response_time = data.get("response_time_ms", 0)
                    
                    # Score based on characteristics
                    for os_name, signature in self.os_signatures.items():
                        score = 0
                        
                        if window_size and "tcp_window_size" in signature:
                            min_win, max_win = signature["tcp_window_size"]
                            if min_win <= window_size <= max_win:
                                score += 20
                        
                        os_scores[os_name] = os_scores.get(os_name, 0) + score
        
        # Analyze ICMP fingerprints
        icmp_data = fingerprint_results.get("icmp_fingerprint", {})
        for test, data in icmp_data.items():
            if data.get("success"):
                ttl = data.get("ttl")
                
                for os_name, signature in self.os_signatures.items():
                    score = 0
                    
                    if ttl and "ttl_range" in signature:
                        min_ttl, max_ttl = signature["ttl_range"]
                        if min_ttl <= ttl <= max_ttl:
                            score += 30
                    
                    os_scores[os_name] = os_scores.get(os_name, 0) + score
        
        # Analyze service banners
        banner_data = fingerprint_results.get("service_banners", {})
        for port, info in banner_data.items():
            os_hints = info.get("os_hints", [])
            for hint in os_hints:
                os_scores[hint] = os_scores.get(hint, 0) + 40
        
        # Determine most likely OS
        if os_scores:
            sorted_scores = sorted(os_scores.items(), key=lambda x: x[1], reverse=True)
            return {
                "most_likely": sorted_scores[0][0],
                "confidence": min(sorted_scores[0][1], 100),
                "all_scores": dict(sorted_scores)
            }
        
        return {"most_likely": "unknown", "confidence": 0, "all_scores": {}}
    
    def _calculate_confidence(self, fingerprint_results: Dict) -> Dict:
        """Calculate confidence scores for OS detection"""
        confidence_factors = {}
        
        # TCP fingerprint confidence
        tcp_data = fingerprint_results.get("tcp_fingerprint", {})
        tcp_confidence = min(len(tcp_data) * 20, 60)
        confidence_factors["tcp_fingerprint"] = tcp_confidence
        
        # ICMP fingerprint confidence
        icmp_data = fingerprint_results.get("icmp_fingerprint", {})
        icmp_confidence = min(len(icmp_data) * 15, 45)
        confidence_factors["icmp_fingerprint"] = icmp_confidence
        
        # Service banner confidence
        banner_data = fingerprint_results.get("service_banners", {})
        banner_confidence = min(len(banner_data) * 25, 75)
        confidence_factors["service_banners"] = banner_confidence
        
        # Overall confidence
        overall_confidence = min(sum(confidence_factors.values()), 100)
        confidence_factors["overall"] = overall_confidence
        
        return confidence_factors
    
    def _analyze_os_vulnerabilities(self, fingerprint_results: Dict, host: str):
        """Analyze OS detection results for security implications"""
        
        os_detection = fingerprint_results.get("os_detection", {})
        most_likely_os = os_detection.get("most_likely", "unknown")
        confidence = os_detection.get("confidence", 0)
        
        if confidence > 70:  # High confidence detection
            # Check for potentially vulnerable OS versions
            banner_data = fingerprint_results.get("service_banners", {})
            
            for port, info in banner_data.items():
                banner = info.get("banner", "")
                
                # Check for outdated software versions
                if any(old_version in banner.lower() for old_version in [
                    "openssh_5", "openssh_6", "apache/2.2", "iis/6.0", "iis/7.0"
                ]):
                    vuln = Vulnerability(
                        title="Outdated Software Version Detected",
                        description=f"Service on port {port} appears to be running outdated software: {banner[:100]}",
                        severity=Severity.MEDIUM,
                        affected_component=f"{host}:{port}",
                        recommendation="Update software to latest versions to address known vulnerabilities",
                        evidence={
                            "port": port,
                            "banner": banner,
                            "detected_os": most_likely_os,
                            "confidence": confidence
                        }
                    )
                    self.add_vulnerability(vuln)
        
        # Check for information disclosure
        if confidence > 50:
            vuln = Vulnerability(
                title="OS Fingerprinting Successful",
                description=f"Operating system successfully identified as {most_likely_os} with {confidence}% confidence",
                severity=Severity.LOW,
                affected_component=host,
                recommendation="Consider implementing OS fingerprinting countermeasures to reduce information disclosure",
                evidence={
                    "detected_os": most_likely_os,
                    "confidence": confidence,
                    "detection_methods": list(fingerprint_results.keys()),
                    "os_scores": os_detection.get("all_scores", {})
                }
            )
            self.add_vulnerability(vuln)
        
        # Check for specific OS vulnerabilities
        if most_likely_os == "windows" and confidence > 60:
            # Windows-specific checks
            vuln = Vulnerability(
                title="Windows OS Detected",
                description="Windows operating system detected - verify patch levels and security configurations",
                severity=Severity.INFO,
                affected_component=host,
                recommendation="Ensure Windows updates are current and security features are enabled",
                evidence={
                    "detected_os": most_likely_os,
                    "confidence": confidence,
                    "security_considerations": [
                        "Verify Windows Update status",
                        "Check Windows Defender status",
                        "Review SMB configuration",
                        "Validate user account policies"
                    ]
                }
            )
            self.add_vulnerability(vuln)