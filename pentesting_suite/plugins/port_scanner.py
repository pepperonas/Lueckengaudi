import asyncio
import socket
from typing import Dict, Any, List, Tuple
from datetime import datetime
import sys
sys.path.append('..')

from core.base_plugin import BasePlugin, PluginResult, PluginStatus, Vulnerability, Severity


class PortScanner(BasePlugin):
    def __init__(self):
        super().__init__(
            name="PortScanner",
            version="1.0.0",
            description="TCP/UDP port scanner with service detection"
        )
        
        self.common_ports = {
            21: "FTP",
            22: "SSH",
            23: "Telnet",
            25: "SMTP",
            53: "DNS",
            80: "HTTP",
            110: "POP3",
            111: "RPC",
            135: "MSRPC",
            139: "NetBIOS",
            143: "IMAP",
            443: "HTTPS",
            445: "SMB",
            993: "IMAPS",
            995: "POP3S",
            1723: "PPTP",
            3306: "MySQL",
            3389: "RDP",
            5432: "PostgreSQL",
            5900: "VNC",
            8080: "HTTP-Proxy",
            8443: "HTTPS-Alt",
            27017: "MongoDB"
        }
        
        self.vulnerable_services = {
            23: ("Telnet", "Telnet transmits data in clear text", Severity.HIGH),
            21: ("FTP", "FTP can transmit credentials in clear text", Severity.MEDIUM),
            139: ("NetBIOS", "NetBIOS can expose sensitive information", Severity.MEDIUM),
            445: ("SMB", "SMB can be vulnerable to various attacks", Severity.MEDIUM)
        }
    
    def validate_options(self, options: Dict[str, Any]) -> bool:
        required = ["start_port", "end_port"]
        return all(key in options for key in required)
    
    async def execute(self, target: str, options: Dict[str, Any]) -> PluginResult:
        self.status = PluginStatus.RUNNING
        start_port = options.get("start_port", 1)
        end_port = options.get("end_port", 1000)
        scan_type = options.get("scan_type", "tcp")
        timeout = options.get("timeout", 1)
        
        try:
            ip = socket.gethostbyname(target)
        except socket.gaierror:
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": f"Cannot resolve hostname: {target}"},
                errors=[f"Cannot resolve hostname: {target}"]
            )
        
        open_ports = []
        
        if scan_type.lower() == "tcp":
            open_ports = await self._tcp_scan(ip, start_port, end_port, timeout)
        elif scan_type.lower() == "udp":
            open_ports = await self._udp_scan(ip, start_port, end_port, timeout)
        else:
            open_ports = await self._tcp_scan(ip, start_port, end_port, timeout)
        
        self._analyze_vulnerabilities(open_ports)
        
        self.status = PluginStatus.COMPLETED
        result_data = {
            "target": target,
            "ip": ip,
            "scan_type": scan_type,
            "port_range": f"{start_port}-{end_port}",
            "open_ports": open_ports,
            "total_open": len(open_ports),
            "timestamp": datetime.now().isoformat()
        }
        
        result = PluginResult(
            plugin_name=self.name,
            status=self.status,
            data=result_data,
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(result)
        return result
    
    async def _tcp_scan(self, ip: str, start_port: int, end_port: int, timeout: float) -> List[Dict]:
        open_ports = []
        tasks = []
        
        for port in range(start_port, end_port + 1):
            task = self._check_tcp_port(ip, port, timeout)
            tasks.append(task)
            
            if len(tasks) >= 100:
                results = await asyncio.gather(*tasks)
                open_ports.extend([r for r in results if r])
                tasks = []
        
        if tasks:
            results = await asyncio.gather(*tasks)
            open_ports.extend([r for r in results if r])
        
        return sorted(open_ports, key=lambda x: x['port'])
    
    async def _check_tcp_port(self, ip: str, port: int, timeout: float) -> Dict:
        try:
            _, writer = await asyncio.wait_for(
                asyncio.open_connection(ip, port),
                timeout=timeout
            )
            writer.close()
            await writer.wait_closed()
            
            service = self.common_ports.get(port, "Unknown")
            banner = await self._grab_banner(ip, port, timeout)
            
            return {
                "port": port,
                "state": "open",
                "service": service,
                "banner": banner
            }
        except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
            return None
    
    async def _grab_banner(self, ip: str, port: int, timeout: float) -> str:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(ip, port),
                timeout=timeout
            )
            
            writer.write(b"\r\n")
            await writer.drain()
            
            banner = await asyncio.wait_for(reader.read(1024), timeout=timeout)
            writer.close()
            await writer.wait_closed()
            
            return banner.decode('utf-8', errors='ignore').strip()
        except:
            return ""
    
    async def _udp_scan(self, ip: str, start_port: int, end_port: int, timeout: float) -> List[Dict]:
        open_ports = []
        
        for port in range(start_port, end_port + 1):
            if await self._check_udp_port(ip, port, timeout):
                service = self.common_ports.get(port, "Unknown")
                open_ports.append({
                    "port": port,
                    "state": "open|filtered",
                    "service": service,
                    "protocol": "udp"
                })
        
        return open_ports
    
    async def _check_udp_port(self, ip: str, port: int, timeout: float) -> bool:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(timeout)
            
            sock.sendto(b"\x00", (ip, port))
            
            try:
                data, _ = sock.recvfrom(1024)
                sock.close()
                return True
            except socket.timeout:
                sock.close()
                return False
        except:
            return False
    
    def _analyze_vulnerabilities(self, open_ports: List[Dict]):
        for port_info in open_ports:
            port = port_info['port']
            if port in self.vulnerable_services:
                service, description, severity = self.vulnerable_services[port]
                
                vuln = Vulnerability(
                    title=f"Potentially Vulnerable Service: {service}",
                    description=description,
                    severity=severity,
                    affected_component=f"Port {port} ({service})",
                    recommendation=f"Consider disabling {service} or implementing proper security controls",
                    evidence={"port": port, "service": service, "banner": port_info.get('banner', '')}
                )
                
                self.add_vulnerability(vuln)