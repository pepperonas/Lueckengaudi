import asyncio
import socket
from typing import Dict, Any, List, Tuple, Optional
from datetime import datetime
import struct
import sys
sys.path.append('..')

from core.base_plugin import BasePlugin, PluginResult, PluginStatus, Vulnerability, Severity


class SMBEnumerator(BasePlugin):
    def __init__(self):
        super().__init__(
            name="SMBEnumerator",
            version="1.0.0",
            description="SMB/CIFS service enumeration and security testing"
        )
        
        # Common SMB ports
        self.smb_ports = [139, 445]
        
        # Common share names
        self.common_shares = [
            "ADMIN$", "C$", "D$", "E$", "IPC$", "NETLOGON", "SYSVOL",
            "share", "shares", "public", "backup", "backups", "data",
            "files", "documents", "users", "home", "homes", "www",
            "web", "ftp", "temp", "tmp", "transfer", "exchange"
        ]
        
        # Common usernames for SMB
        self.common_usernames = [
            "administrator", "admin", "guest", "user", "test", "demo",
            "backup", "service", "operator", "support", "anonymous",
            "root", "sa", "sql", "oracle", "postgres", "mysql"
        ]
        
        # Common passwords
        self.common_passwords = [
            "", "password", "admin", "administrator", "guest", "123456",
            "password123", "admin123", "root", "test", "demo", "backup",
            "service", "welcome", "letmein", "access", "system"
        ]
        
        # SMB protocol constants
        self.SMB_COM_NEGOTIATE = 0x72
        self.SMB_COM_SESSION_SETUP_ANDX = 0x73
        self.SMB_COM_TREE_CONNECT_ANDX = 0x75
        self.SMB_COM_NT_CREATE_ANDX = 0xa2
        
        self.smb_timeout = 10
    
    def validate_options(self, options: Dict[str, Any]) -> bool:
        return "host" in options
    
    async def execute(self, target: str, options: Dict[str, Any]) -> PluginResult:
        self.status = PluginStatus.RUNNING
        
        host = options.get("host", target)
        ports = options.get("ports", self.smb_ports)
        test_shares = options.get("test_shares", True)
        test_null_sessions = options.get("test_null_sessions", True)
        enumerate_users = options.get("enumerate_users", True)
        custom_shares = options.get("custom_shares", [])
        
        # Respect safe mode
        if self.is_safe_mode:
            ports = [445]  # Only test modern SMB port
            test_shares = False
            enumerate_users = False
        
        smb_analysis = {
            "ports_tested": ports,
            "open_ports": [],
            "smb_info": {},
            "shares": [],
            "null_session": False,
            "users": [],
            "vulnerabilities": []
        }
        
        try:
            # Test SMB ports
            for port in ports:
                if await self._check_smb_port(host, port):
                    smb_analysis["open_ports"].append(port)
                    
                    # Get SMB information
                    smb_info = await self._get_smb_info(host, port)
                    smb_analysis["smb_info"][port] = smb_info
                    
                    # Test null sessions
                    if test_null_sessions:
                        null_result = await self._test_null_session(host, port)
                        if null_result["success"]:
                            smb_analysis["null_session"] = True
                            
                            # Enumerate shares with null session
                            if test_shares:
                                shares = await self._enumerate_shares(host, port, "", "")
                                smb_analysis["shares"].extend(shares)
                            
                            # Enumerate users with null session
                            if enumerate_users:
                                users = await self._enumerate_users(host, port, "", "")
                                smb_analysis["users"].extend(users)
                    
                    # Test custom shares if provided
                    if custom_shares:
                        for share in custom_shares:
                            share_info = await self._test_share_access(host, port, share, "", "")
                            if share_info:
                                smb_analysis["shares"].append(share_info)
                    
                    # Test common shares
                    if test_shares and not self.is_safe_mode:
                        for share in self.common_shares[:10]:  # Limit testing
                            share_info = await self._test_share_access(host, port, share, "", "")
                            if share_info:
                                smb_analysis["shares"].append(share_info)
            
            if not smb_analysis["open_ports"]:
                self.status = PluginStatus.FAILED
                return PluginResult(
                    plugin_name=self.name,
                    status=self.status,
                    data={"error": f"No SMB services found on {host}"},
                    errors=[f"No SMB services found on {host}"]
                )
        
        except Exception as e:
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": str(e)},
                errors=[str(e)]
            )
        
        # Analyze findings for vulnerabilities
        self._analyze_smb_vulnerabilities(smb_analysis, host)
        
        self.status = PluginStatus.COMPLETED
        result_data = {
            "target": target,
            "host": host,
            **smb_analysis,
            "timestamp": datetime.now().isoformat()
        }
        
        result = PluginResult(
            plugin_name=self.name,
            status=self.status,
            data=result_data,
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(result)
        return result
    
    async def _check_smb_port(self, host: str, port: int) -> bool:
        """Check if SMB port is open"""
        try:
            _, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=self.smb_timeout
            )
            writer.close()
            await writer.wait_closed()
            return True
        except:
            return False
    
    async def _get_smb_info(self, host: str, port: int) -> Dict:
        """Get SMB service information"""
        info = {}
        
        try:
            if self._rate_limiter:
                async with self._rate_limiter:
                    info = await self._perform_smb_info(host, port)
            else:
                info = await self._perform_smb_info(host, port)
        except Exception as e:
            info["error"] = str(e)
        
        return info
    
    async def _perform_smb_info(self, host: str, port: int) -> Dict:
        """Perform SMB information gathering"""
        info = {
            "port": port,
            "protocol_version": None,
            "server_name": None,
            "domain": None,
            "os_version": None,
            "smb_version": None
        }
        
        try:
            # Create SMB negotiate request
            reader, writer = await asyncio.open_connection(host, port)
            
            # Send SMB negotiate request
            negotiate_packet = self._create_smb_negotiate_packet()
            writer.write(negotiate_packet)
            await writer.drain()
            
            # Read response
            response = await asyncio.wait_for(reader.read(4096), timeout=5)
            
            if response:
                # Parse SMB response
                parsed_info = self._parse_smb_negotiate_response(response)
                info.update(parsed_info)
            
            writer.close()
            await writer.wait_closed()
            
        except Exception as e:
            info["connection_error"] = str(e)
        
        return info
    
    def _create_smb_negotiate_packet(self) -> bytes:
        """Create SMB negotiate protocol packet"""
        # SMB Header
        smb_header = b'\xffSMB'  # Protocol identifier
        smb_header += struct.pack('<B', self.SMB_COM_NEGOTIATE)  # Command
        smb_header += b'\x00' * 4  # Status
        smb_header += b'\x18'  # Flags
        smb_header += b'\x00' * 2  # Flags2
        smb_header += b'\x00' * 12  # Process ID, Tree ID, User ID, Multiplex ID
        
        # SMB parameters
        smb_params = b'\x00'  # Word count
        
        # SMB data (dialect strings)
        dialects = [
            b'\x02PC NETWORK PROGRAM 1.0\x00',
            b'\x02LANMAN1.0\x00',
            b'\x02Windows for Workgroups 3.1a\x00',
            b'\x02LM1.2X002\x00',
            b'\x02LANMAN2.1\x00',
            b'\x02NT LM 0.12\x00',
            b'\x02SMB 2.002\x00',
            b'\x02SMB 2.???\x00'
        ]
        
        smb_data = b''.join(dialects)
        smb_data_len = struct.pack('<H', len(smb_data))
        
        # NetBIOS session header
        netbios_header = b'\x00'  # Message type (session message)
        netbios_header += struct.pack('>I', len(smb_header + smb_params + smb_data_len + smb_data))[1:]
        
        return netbios_header + smb_header + smb_params + smb_data_len + smb_data
    
    def _parse_smb_negotiate_response(self, response: bytes) -> Dict:
        """Parse SMB negotiate response"""
        info = {}
        
        try:
            if len(response) < 4:
                return info
            
            # Skip NetBIOS header (4 bytes)
            smb_data = response[4:]
            
            if len(smb_data) < 32 or not smb_data.startswith(b'\xffSMB'):
                return info
            
            # Parse SMB header
            command = smb_data[4]
            if command == self.SMB_COM_NEGOTIATE:
                info["smb_negotiate_success"] = True
                
                # Try to extract server information from response
                # This is a simplified parser - full implementation would be more complex
                try:
                    # Look for server name and domain in the response
                    response_str = smb_data.decode('utf-8', errors='ignore')
                    
                    # Extract any readable strings that might contain server info
                    strings = []
                    current_string = ""
                    for char in response_str:
                        if char.isprintable() and char != '\x00':
                            current_string += char
                        else:
                            if len(current_string) > 3:
                                strings.append(current_string)
                            current_string = ""
                    
                    if strings:
                        info["extracted_strings"] = strings[:5]  # Limit to first 5 strings
                
                except:
                    pass
        
        except Exception:
            pass
        
        return info
    
    async def _test_null_session(self, host: str, port: int) -> Dict:
        """Test for null session access"""
        result = {
            "success": False,
            "error": None,
            "accessible_shares": []
        }
        
        try:
            # Try to connect with empty credentials
            # This is a simplified test - real implementation would use proper SMB protocol
            reader, writer = await asyncio.open_connection(host, port)
            
            # For now, just test if we can connect (null session testing requires full SMB implementation)
            # In a real implementation, this would send proper SMB session setup packets
            result["connection_success"] = True
            
            writer.close()
            await writer.wait_closed()
            
            # Placeholder for actual null session test
            result["success"] = False  # Would be determined by actual SMB protocol exchange
            
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    async def _enumerate_shares(self, host: str, port: int, username: str, password: str) -> List[Dict]:
        """Enumerate SMB shares"""
        shares = []
        
        # Test common share names
        for share_name in self.common_shares:
            share_info = await self._test_share_access(host, port, share_name, username, password)
            if share_info:
                shares.append(share_info)
        
        return shares
    
    async def _test_share_access(self, host: str, port: int, share_name: str, 
                               username: str, password: str) -> Optional[Dict]:
        """Test access to a specific SMB share"""
        if self._rate_limiter:
            async with self._rate_limiter:
                return await self._perform_share_test(host, port, share_name, username, password)
        return await self._perform_share_test(host, port, share_name, username, password)
    
    async def _perform_share_test(self, host: str, port: int, share_name: str, 
                                username: str, password: str) -> Optional[Dict]:
        """Perform the actual share access test"""
        share_info = {
            "name": share_name,
            "accessible": False,
            "readable": False,
            "writable": False,
            "error": None
        }
        
        try:
            # This is a simplified test - real implementation would use proper SMB protocol
            # For now, we'll just test basic connectivity and infer share existence
            
            reader, writer = await asyncio.open_connection(host, port)
            
            # Send a basic request (in real implementation, this would be SMB Tree Connect)
            # For demonstration, we'll just check if the connection works
            share_info["connection_success"] = True
            share_info["accessible"] = True  # Placeholder - would be determined by SMB response
            
            writer.close()
            await writer.wait_closed()
            
            return share_info
            
        except Exception as e:
            share_info["error"] = str(e)
            return None
    
    async def _enumerate_users(self, host: str, port: int, username: str, password: str) -> List[str]:
        """Enumerate SMB users"""
        users = []
        
        try:
            # This would require proper SMB protocol implementation
            # For now, return empty list as placeholder
            # Real implementation would use SMB commands like NetUserEnum
            pass
        
        except Exception:
            pass
        
        return users
    
    def _analyze_smb_vulnerabilities(self, smb_analysis: Dict, host: str):
        """Analyze SMB findings for vulnerabilities"""
        
        for port in smb_analysis["open_ports"]:
            target = f"{host}:{port}"
            
            # Check for SMBv1 (port 139 typically indicates older SMB)
            if port == 139:
                vuln = Vulnerability(
                    title="SMBv1 Protocol Enabled",
                    description=f"SMB service on port {port} may support vulnerable SMBv1 protocol",
                    severity=Severity.HIGH,
                    affected_component=target,
                    recommendation="Disable SMBv1 and use SMBv2/v3 only",
                    evidence={
                        "port": port,
                        "smb_info": smb_analysis["smb_info"].get(port, {}),
                        "protocol_concern": "SMBv1 vulnerable to EternalBlue and other exploits"
                    }
                )
                self.add_vulnerability(vuln)
            
            # Check for null session access
            if smb_analysis["null_session"]:
                vuln = Vulnerability(
                    title="SMB Null Session Access",
                    description="SMB service allows null session authentication",
                    severity=Severity.MEDIUM,
                    affected_component=target,
                    recommendation="Disable null session access and require authentication",
                    evidence={
                        "null_session_enabled": True,
                        "accessible_shares": [s["name"] for s in smb_analysis["shares"] if s.get("accessible")],
                        "enumerated_users": smb_analysis["users"]
                    }
                )
                self.add_vulnerability(vuln)
            
            # Check for accessible administrative shares
            admin_shares = [s for s in smb_analysis["shares"] 
                          if s.get("accessible") and s["name"] in ["ADMIN$", "C$", "D$", "E$"]]
            
            if admin_shares:
                vuln = Vulnerability(
                    title="Administrative Shares Accessible",
                    description=f"Administrative SMB shares are accessible: {', '.join([s['name'] for s in admin_shares])}",
                    severity=Severity.HIGH,
                    affected_component=target,
                    recommendation="Restrict access to administrative shares",
                    evidence={
                        "admin_shares": [s["name"] for s in admin_shares],
                        "share_details": admin_shares
                    }
                )
                self.add_vulnerability(vuln)
            
            # Check for writable shares
            writable_shares = [s for s in smb_analysis["shares"] 
                             if s.get("writable", False)]
            
            if writable_shares:
                vuln = Vulnerability(
                    title="Writable SMB Shares",
                    description=f"SMB shares with write access found: {', '.join([s['name'] for s in writable_shares])}",
                    severity=Severity.MEDIUM,
                    affected_component=target,
                    recommendation="Review and restrict write permissions on SMB shares",
                    evidence={
                        "writable_shares": [s["name"] for s in writable_shares],
                        "share_details": writable_shares
                    }
                )
                self.add_vulnerability(vuln)
            
            # Check for information disclosure
            smb_info = smb_analysis["smb_info"].get(port, {})
            if smb_info.get("extracted_strings"):
                strings = smb_info["extracted_strings"]
                if any(len(s) > 5 for s in strings):  # Potentially useful information
                    vuln = Vulnerability(
                        title="SMB Information Disclosure",
                        description="SMB service reveals system information in responses",
                        severity=Severity.LOW,
                        affected_component=target,
                        recommendation="Configure SMB to minimize information disclosure",
                        evidence={
                            "disclosed_information": strings,
                            "smb_info": smb_info
                        }
                    )
                    self.add_vulnerability(vuln)