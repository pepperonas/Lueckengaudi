import asyncio
import paramiko
from typing import Dict, Any, List, Tuple, Optional
from datetime import datetime
import socket
import threading
import sys
sys.path.append('..')

from core.base_plugin import BasePlugin, PluginResult, PluginStatus, Vulnerability, Severity


class SSHBruteforce(BasePlugin):
    def __init__(self):
        super().__init__(
            name="SSHBruteforce",
            version="1.0.0",
            description="SSH bruteforce attack for credential discovery"
        )
        
        # Common SSH usernames
        self.common_usernames = [
            "root", "admin", "administrator", "user", "guest", "test",
            "oracle", "postgres", "mysql", "apache", "www", "ftp",
            "mail", "email", "service", "support", "backup", "nagios",
            "zabbix", "monitor", "operator", "deploy", "jenkins",
            "git", "svn", "tomcat", "ubuntu", "centos", "debian",
            "redhat", "suse", "pi", "cisco", "juniper", "vyos"
        ]
        
        # Common SSH passwords
        self.common_passwords = [
            "password", "123456", "admin", "root", "guest", "test",
            "password123", "admin123", "root123", "123123", "qwerty",
            "abc123", "letmein", "welcome", "monkey", "dragon",
            "master", "shadow", "1234567890", "654321", "superman",
            "batman", "football", "baseball", "access", "system",
            "server", "oracle", "postgres", "mysql", "apache",
            "tomcat", "jenkins", "nagios", "zabbix", "backup",
            "", "admin", "password", "root", "guest"  # Empty password and duplicates for emphasis
        ]
        
        # Default credentials for specific services/devices
        self.default_credentials = [
            ("admin", "admin"),
            ("root", "root"),
            ("admin", "password"),
            ("root", "password"),
            ("admin", "123456"),
            ("root", "123456"),
            ("admin", ""),
            ("root", ""),
            ("guest", "guest"),
            ("user", "user"),
            ("test", "test"),
            ("oracle", "oracle"),
            ("postgres", "postgres"),
            ("mysql", "mysql"),
            ("tomcat", "tomcat"),
            ("jenkins", "jenkins"),
            ("nagios", "nagios"),
            ("pi", "raspberry"),
            ("ubuntu", "ubuntu"),
            ("centos", "centos"),
            ("debian", "debian"),
            ("cisco", "cisco"),
            ("admin", "cisco"),
            ("enable", "enable")
        ]
        
        # SSH connection timeout
        self.ssh_timeout = 5
        self.max_concurrent = 10
    
    def validate_options(self, options: Dict[str, Any]) -> bool:
        return "host" in options
    
    async def execute(self, target: str, options: Dict[str, Any]) -> PluginResult:
        self.status = PluginStatus.RUNNING
        
        host = options.get("host", target)
        port = options.get("port", 22)
        username_list = options.get("usernames", self.common_usernames[:10])  # Limit in safe mode
        password_list = options.get("passwords", self.common_passwords[:10])  # Limit in safe mode
        wordlist_file = options.get("wordlist", None)
        max_concurrent = options.get("max_concurrent", self.max_concurrent)
        
        # Respect safe mode
        if self.is_safe_mode:
            username_list = username_list[:5]
            password_list = password_list[:5]
            max_concurrent = min(max_concurrent, 3)
        
        successful_logins = []
        failed_attempts = 0
        
        try:
            # First check if SSH service is available
            if not await self._check_ssh_service(host, port):
                self.status = PluginStatus.FAILED
                return PluginResult(
                    plugin_name=self.name,
                    status=self.status,
                    data={"error": f"SSH service not available on {host}:{port}"},
                    errors=[f"SSH service not available on {host}:{port}"]
                )
            
            # Load custom wordlist if provided
            if wordlist_file:
                custom_creds = await self._load_wordlist(wordlist_file)
                if custom_creds:
                    username_list, password_list = custom_creds
            
            # Test default credentials first
            for username, password in self.default_credentials[:10]:
                if self.is_safe_mode and len(successful_logins) > 0:
                    break  # Stop after first success in safe mode
                
                result = await self._test_ssh_login(host, port, username, password)
                if result["success"]:
                    successful_logins.append(result)
                    break  # Stop after finding valid credentials
                else:
                    failed_attempts += 1
            
            # If no default credentials worked, try bruteforce
            if not successful_logins:
                semaphore = asyncio.Semaphore(max_concurrent)
                tasks = []
                
                for username in username_list:
                    if self.is_safe_mode and failed_attempts > 20:
                        break  # Limit attempts in safe mode
                    
                    for password in password_list:
                        if self.is_safe_mode and failed_attempts > 20:
                            break
                        
                        task = self._bruteforce_credential(semaphore, host, port, username, password)
                        tasks.append(task)
                
                results = await asyncio.gather(*tasks, return_exceptions=True)
                
                for result in results:
                    if isinstance(result, dict):
                        if result.get("success"):
                            successful_logins.append(result)
                        else:
                            failed_attempts += 1
            
        except Exception as e:
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": str(e)},
                errors=[str(e)]
            )
        
        # Analyze findings for vulnerabilities
        self._analyze_ssh_vulnerabilities(successful_logins, host, port, failed_attempts)
        
        self.status = PluginStatus.COMPLETED
        result_data = {
            "target": target,
            "host": host,
            "port": port,
            "successful_logins": successful_logins,
            "failed_attempts": failed_attempts,
            "credentials_found": len(successful_logins),
            "timestamp": datetime.now().isoformat()
        }
        
        result = PluginResult(
            plugin_name=self.name,
            status=self.status,
            data=result_data,
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(result)
        return result
    
    async def _check_ssh_service(self, host: str, port: int) -> bool:
        """Check if SSH service is available"""
        try:
            _, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=self.ssh_timeout
            )
            writer.close()
            await writer.wait_closed()
            return True
        except:
            return False
    
    async def _load_wordlist(self, wordlist_file: str) -> Optional[Tuple[List[str], List[str]]]:
        """Load custom wordlist from file"""
        try:
            usernames = []
            passwords = []
            
            with open(wordlist_file, 'r') as f:
                lines = [line.strip() for line in f if line.strip()]
            
            # Simple format: username:password per line
            for line in lines:
                if ':' in line:
                    username, password = line.split(':', 1)
                    usernames.append(username)
                    passwords.append(password)
                else:
                    # Treat as password list if no colon
                    passwords.append(line)
            
            # If no usernames found, use common ones
            if not usernames:
                usernames = self.common_usernames[:10]
            
            return usernames, passwords
            
        except Exception:
            return None
    
    async def _bruteforce_credential(self, semaphore: asyncio.Semaphore, 
                                   host: str, port: int, username: str, password: str) -> Dict:
        """Test a single SSH credential"""
        async with semaphore:
            if self._rate_limiter:
                async with self._rate_limiter:
                    return await self._test_ssh_login(host, port, username, password)
            return await self._test_ssh_login(host, port, username, password)
    
    async def _test_ssh_login(self, host: str, port: int, username: str, password: str) -> Dict:
        """Test SSH login with given credentials"""
        result = {
            "username": username,
            "password": password,
            "success": False,
            "error": None,
            "banner": None,
            "server_version": None
        }
        
        try:
            # Run SSH connection in thread to avoid blocking
            loop = asyncio.get_event_loop()
            ssh_result = await loop.run_in_executor(
                None,
                self._ssh_connect_sync,
                host, port, username, password
            )
            
            result.update(ssh_result)
            
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def _ssh_connect_sync(self, host: str, port: int, username: str, password: str) -> Dict:
        """Synchronous SSH connection test"""
        result = {
            "success": False,
            "error": None,
            "banner": None,
            "server_version": None,
            "auth_methods": []
        }
        
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        try:
            # Get SSH banner and version info
            transport = paramiko.Transport((host, port))
            transport.start_client(timeout=self.ssh_timeout)
            
            result["server_version"] = transport.remote_version
            result["banner"] = transport.get_banner()
            
            # Get supported authentication methods
            try:
                transport.auth_none(username)
            except paramiko.BadAuthenticationType as e:
                result["auth_methods"] = e.allowed_types
            except:
                pass
            
            transport.close()
            
            # Attempt login
            ssh.connect(
                hostname=host,
                port=port,
                username=username,
                password=password,
                timeout=self.ssh_timeout,
                allow_agent=False,
                look_for_keys=False,
                banner_timeout=self.ssh_timeout
            )
            
            # If we get here, login was successful
            result["success"] = True
            
            # Try to execute a simple command to verify access
            try:
                stdin, stdout, stderr = ssh.exec_command('id', timeout=5)
                command_output = stdout.read().decode('utf-8', errors='ignore').strip()
                result["command_test"] = command_output
            except:
                result["command_test"] = "Command execution failed"
            
        except paramiko.AuthenticationException:
            result["error"] = "Authentication failed"
        except paramiko.SSHException as e:
            result["error"] = f"SSH error: {str(e)}"
        except socket.timeout:
            result["error"] = "Connection timeout"
        except Exception as e:
            result["error"] = f"Connection error: {str(e)}"
        finally:
            try:
                ssh.close()
            except:
                pass
        
        return result
    
    def _analyze_ssh_vulnerabilities(self, successful_logins: List[Dict], 
                                   host: str, port: int, failed_attempts: int):
        """Analyze SSH findings for vulnerabilities"""
        
        target = f"{host}:{port}"
        
        # Check for successful logins (weak credentials)
        for login in successful_logins:
            username = login["username"]
            password = login["password"]
            
            # Determine severity based on credentials
            if password == "" or password == username:
                severity = Severity.CRITICAL
                description = f"SSH service allows login with empty or trivial password"
            elif (username, password) in self.default_credentials:
                severity = Severity.HIGH
                description = f"SSH service using default credentials: {username}:{password}"
            elif password in ["password", "123456", "admin", "root"]:
                severity = Severity.HIGH
                description = f"SSH service using weak password: {username}:{password}"
            else:
                severity = Severity.MEDIUM
                description = f"SSH service allows bruteforce login: {username}:{password}"
            
            vuln = Vulnerability(
                title="Weak SSH Credentials",
                description=description,
                severity=severity,
                affected_component=target,
                recommendation="Use strong passwords, implement key-based authentication, and disable password authentication",
                evidence={
                    "username": username,
                    "password": password,
                    "server_version": login.get("server_version"),
                    "auth_methods": login.get("auth_methods", []),
                    "command_test": login.get("command_test"),
                    "successful_login": True
                }
            )
            self.add_vulnerability(vuln)
        
        # Check for potential bruteforce vulnerability
        if failed_attempts > 10 and not successful_logins:
            vuln = Vulnerability(
                title="SSH Bruteforce Vulnerability",
                description=f"SSH service on {target} allows unlimited login attempts without lockout",
                severity=Severity.MEDIUM,
                affected_component=target,
                recommendation="Implement fail2ban, account lockout policies, or rate limiting",
                evidence={
                    "failed_attempts": failed_attempts,
                    "no_rate_limiting": True,
                    "bruteforce_possible": True
                }
            )
            self.add_vulnerability(vuln)
        
        # Check for information disclosure in banners
        if successful_logins:
            login = successful_logins[0]
            server_version = login.get("server_version", "")
            banner = login.get("banner", "")
            
            if server_version and any(old_version in server_version.lower() 
                                    for old_version in ["openssh_5", "openssh_6", "openssh_7.0", "openssh_7.1"]):
                vuln = Vulnerability(
                    title="Outdated SSH Server Version",
                    description=f"SSH server running potentially vulnerable version: {server_version}",
                    severity=Severity.MEDIUM,
                    affected_component=target,
                    recommendation="Update SSH server to the latest version",
                    evidence={
                        "server_version": server_version,
                        "banner": banner,
                        "outdated_version": True
                    }
                )
                self.add_vulnerability(vuln)