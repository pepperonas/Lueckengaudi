import asyncio
import ssl
import socket
from typing import Dict, Any, List, Tuple, Optional
from datetime import datetime, timedelta
import OpenSSL
from cryptography import x509
from cryptography.hazmat.backends import default_backend
import sys
sys.path.append('..')

from core.base_plugin import BasePlugin, PluginResult, PluginStatus, Vulnerability, Severity


class SSLTLSAnalyzer(BasePlugin):
    def __init__(self):
        super().__init__(
            name="SSLTLSAnalyzer",
            version="1.0.0",
            description="SSL/TLS configuration and certificate security analyzer"
        )
        
        # Weak protocols that should not be used
        self.weak_protocols = {
            ssl.PROTOCOL_SSLv2: "SSLv2",
            ssl.PROTOCOL_SSLv3: "SSLv3",
            ssl.PROTOCOL_TLSv1: "TLSv1.0",
            ssl.PROTOCOL_TLSv1_1: "TLSv1.1"
        }
        
        # Strong protocols
        self.strong_protocols = {
            ssl.PROTOCOL_TLSv1_2: "TLSv1.2",
            ssl.PROTOCOL_TLS: "TLS (latest)"
        }
        
        # Weak cipher suites (partial list)
        self.weak_ciphers = [
            "NULL", "aNULL", "eNULL", "EXPORT", "DES", "RC4", "MD5",
            "PSK", "SRP", "3DES", "ADH", "AECDH", "LOW", "EXP"
        ]
        
        # Strong cipher suites
        self.strong_ciphers = [
            "ECDHE", "AES256", "AES128", "GCM", "SHA256", "SHA384"
        ]
        
        # Common ports to test
        self.common_ssl_ports = [443, 8443, 993, 995, 465, 636, 990, 992]
        
        # Certificate validation issues
        self.cert_issues = {
            "expired": "Certificate has expired",
            "not_yet_valid": "Certificate is not yet valid",
            "self_signed": "Self-signed certificate",
            "weak_signature": "Weak signature algorithm",
            "short_key": "Key length too short",
            "wrong_hostname": "Certificate hostname mismatch"
        }
    
    def validate_options(self, options: Dict[str, Any]) -> bool:
        return "host" in options
    
    async def execute(self, target: str, options: Dict[str, Any]) -> PluginResult:
        self.status = PluginStatus.RUNNING
        
        host = options.get("host", target)
        port = options.get("port", 443)
        timeout = options.get("timeout", 10)
        test_all_ports = options.get("test_all_ports", False)
        
        ssl_analysis = {}
        
        try:
            if test_all_ports:
                # Test multiple common SSL ports
                for test_port in self.common_ssl_ports:
                    if await self._port_is_open(host, test_port, timeout):
                        port_analysis = await self._analyze_ssl_port(host, test_port, timeout)
                        if port_analysis:
                            ssl_analysis[test_port] = port_analysis
            else:
                # Test single port
                port_analysis = await self._analyze_ssl_port(host, port, timeout)
                if port_analysis:
                    ssl_analysis[port] = port_analysis
            
            if not ssl_analysis:
                self.status = PluginStatus.FAILED
                return PluginResult(
                    plugin_name=self.name,
                    status=self.status,
                    data={"error": f"No SSL/TLS services found on {host}"},
                    errors=[f"No SSL/TLS services found on {host}"]
                )
            
        except Exception as e:
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": str(e)},
                errors=[str(e)]
            )
        
        # Analyze findings for vulnerabilities
        self._analyze_ssl_vulnerabilities(ssl_analysis, host)
        
        self.status = PluginStatus.COMPLETED
        result_data = {
            "target": target,
            "host": host,
            "ssl_analysis": ssl_analysis,
            "ports_tested": list(ssl_analysis.keys()),
            "timestamp": datetime.now().isoformat()
        }
        
        result = PluginResult(
            plugin_name=self.name,
            status=self.status,
            data=result_data,
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(result)
        return result
    
    async def _port_is_open(self, host: str, port: int, timeout: int) -> bool:
        """Check if a port is open"""
        try:
            _, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=timeout
            )
            writer.close()
            await writer.wait_closed()
            return True
        except:
            return False
    
    async def _analyze_ssl_port(self, host: str, port: int, timeout: int) -> Optional[Dict]:
        """Analyze SSL/TLS configuration on a specific port"""
        analysis = {
            "port": port,
            "protocols": {},
            "ciphers": [],
            "certificate": {},
            "vulnerabilities": []
        }
        
        try:
            # Test different SSL/TLS protocols
            analysis["protocols"] = await self._test_protocols(host, port, timeout)
            
            # Get certificate information
            analysis["certificate"] = await self._get_certificate_info(host, port, timeout)
            
            # Get cipher suites
            analysis["ciphers"] = await self._get_cipher_suites(host, port, timeout)
            
            # Test for specific vulnerabilities
            analysis["vulnerabilities"] = await self._test_ssl_vulnerabilities(host, port, timeout)
            
            return analysis
            
        except Exception as e:
            return None
    
    async def _test_protocols(self, host: str, port: int, timeout: int) -> Dict:
        """Test which SSL/TLS protocols are supported"""
        protocols = {}
        
        # Test protocols in a separate thread to avoid blocking
        loop = asyncio.get_event_loop()
        
        # Test different protocol versions
        test_protocols = [
            (ssl.PROTOCOL_TLS, "TLS (latest)"),
            (ssl.PROTOCOL_TLSv1_2, "TLSv1.2"),
            (ssl.PROTOCOL_TLSv1_1, "TLSv1.1"),
            (ssl.PROTOCOL_TLSv1, "TLSv1.0"),
        ]
        
        # Add SSLv3 test if available
        try:
            test_protocols.append((ssl.PROTOCOL_SSLv3, "SSLv3"))
        except AttributeError:
            pass
        
        for protocol, name in test_protocols:
            try:
                supported = await loop.run_in_executor(
                    None, 
                    self._test_protocol_sync, 
                    host, port, protocol, timeout
                )
                protocols[name] = supported
            except Exception:
                protocols[name] = False
        
        return protocols
    
    def _test_protocol_sync(self, host: str, port: int, protocol, timeout: int) -> bool:
        """Synchronous protocol test"""
        try:
            context = ssl.SSLContext(protocol)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            sock = socket.create_connection((host, port), timeout=timeout)
            ssl_sock = context.wrap_socket(sock)
            ssl_sock.close()
            return True
        except:
            return False
    
    async def _get_certificate_info(self, host: str, port: int, timeout: int) -> Dict:
        """Get SSL certificate information"""
        cert_info = {}
        
        try:
            loop = asyncio.get_event_loop()
            cert_info = await loop.run_in_executor(
                None,
                self._get_certificate_sync,
                host, port, timeout
            )
        except Exception:
            pass
        
        return cert_info
    
    def _get_certificate_sync(self, host: str, port: int, timeout: int) -> Dict:
        """Synchronous certificate retrieval"""
        cert_info = {}
        
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            sock = socket.create_connection((host, port), timeout=timeout)
            ssl_sock = context.wrap_socket(sock, server_hostname=host)
            
            # Get certificate in DER format
            der_cert = ssl_sock.getpeercert(binary_form=True)
            
            if der_cert:
                # Parse certificate using cryptography library
                cert = x509.load_der_x509_certificate(der_cert, default_backend())
                
                cert_info = {
                    "subject": str(cert.subject),
                    "issuer": str(cert.issuer),
                    "not_valid_before": cert.not_valid_before.isoformat(),
                    "not_valid_after": cert.not_valid_after.isoformat(),
                    "serial_number": str(cert.serial_number),
                    "version": cert.version.name,
                    "signature_algorithm": cert.signature_algorithm_oid._name,
                    "public_key_algorithm": cert.public_key().__class__.__name__,
                    "key_size": self._get_key_size(cert.public_key()),
                    "san": self._get_san(cert),
                    "days_until_expiry": (cert.not_valid_after - datetime.now()).days
                }
            
            ssl_sock.close()
            
        except Exception as e:
            cert_info["error"] = str(e)
        
        return cert_info
    
    def _get_key_size(self, public_key) -> Optional[int]:
        """Get the size of the public key"""
        try:
            if hasattr(public_key, 'key_size'):
                return public_key.key_size
            elif hasattr(public_key, 'curve'):
                return public_key.curve.key_size
        except:
            pass
        return None
    
    def _get_san(self, cert) -> List[str]:
        """Get Subject Alternative Names from certificate"""
        san_list = []
        try:
            san_extension = cert.extensions.get_extension_for_oid(
                x509.oid.ExtensionOID.SUBJECT_ALTERNATIVE_NAME
            )
            for name in san_extension.value:
                san_list.append(str(name.value))
        except:
            pass
        return san_list
    
    async def _get_cipher_suites(self, host: str, port: int, timeout: int) -> List[str]:
        """Get supported cipher suites"""
        ciphers = []
        
        try:
            loop = asyncio.get_event_loop()
            ciphers = await loop.run_in_executor(
                None,
                self._get_ciphers_sync,
                host, port, timeout
            )
        except Exception:
            pass
        
        return ciphers
    
    def _get_ciphers_sync(self, host: str, port: int, timeout: int) -> List[str]:
        """Synchronous cipher suite enumeration"""
        ciphers = []
        
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            sock = socket.create_connection((host, port), timeout=timeout)
            ssl_sock = context.wrap_socket(sock, server_hostname=host)
            
            cipher = ssl_sock.cipher()
            if cipher:
                ciphers.append(cipher[0])  # Cipher name
            
            ssl_sock.close()
            
        except Exception:
            pass
        
        return ciphers
    
    async def _test_ssl_vulnerabilities(self, host: str, port: int, timeout: int) -> List[str]:
        """Test for specific SSL/TLS vulnerabilities"""
        vulnerabilities = []
        
        # Test for heartbleed (basic check)
        if await self._test_heartbleed(host, port, timeout):
            vulnerabilities.append("Heartbleed")
        
        # Test for POODLE
        if await self._test_poodle(host, port, timeout):
            vulnerabilities.append("POODLE")
        
        # Test for BEAST
        if await self._test_beast(host, port, timeout):
            vulnerabilities.append("BEAST")
        
        return vulnerabilities
    
    async def _test_heartbleed(self, host: str, port: int, timeout: int) -> bool:
        """Basic Heartbleed vulnerability test"""
        # This is a simplified test - a full implementation would send
        # the actual heartbeat request
        try:
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(
                None,
                self._test_heartbleed_sync,
                host, port, timeout
            )
        except:
            return False
    
    def _test_heartbleed_sync(self, host: str, port: int, timeout: int) -> bool:
        """Synchronous Heartbleed test"""
        # Simplified test - checks if TLS 1.0-1.2 is supported
        # Real implementation would send heartbeat extension
        try:
            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            sock = socket.create_connection((host, port), timeout=timeout)
            ssl_sock = context.wrap_socket(sock)
            ssl_sock.close()
            
            # This is a placeholder - real Heartbleed test would be more complex
            return False
        except:
            return False
    
    async def _test_poodle(self, host: str, port: int, timeout: int) -> bool:
        """Test for POODLE vulnerability (SSLv3 support)"""
        try:
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(
                None,
                self._test_sslv3_sync,
                host, port, timeout
            )
        except:
            return False
    
    def _test_sslv3_sync(self, host: str, port: int, timeout: int) -> bool:
        """Test if SSLv3 is supported (POODLE vulnerability)"""
        try:
            context = ssl.SSLContext(ssl.PROTOCOL_SSLv3)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            sock = socket.create_connection((host, port), timeout=timeout)
            ssl_sock = context.wrap_socket(sock)
            ssl_sock.close()
            return True
        except:
            return False
    
    async def _test_beast(self, host: str, port: int, timeout: int) -> bool:
        """Test for BEAST vulnerability (TLS 1.0 with CBC ciphers)"""
        try:
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(
                None,
                self._test_beast_sync,
                host, port, timeout
            )
        except:
            return False
    
    def _test_beast_sync(self, host: str, port: int, timeout: int) -> bool:
        """Test for BEAST vulnerability"""
        try:
            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            sock = socket.create_connection((host, port), timeout=timeout)
            ssl_sock = context.wrap_socket(sock)
            
            cipher = ssl_sock.cipher()
            ssl_sock.close()
            
            # Check if using CBC cipher with TLS 1.0
            if cipher and 'CBC' in cipher[0]:
                return True
                
        except:
            pass
        
        return False
    
    def _analyze_ssl_vulnerabilities(self, ssl_analysis: Dict, host: str):
        """Analyze SSL/TLS configuration for vulnerabilities"""
        
        for port, analysis in ssl_analysis.items():
            port_str = f"{host}:{port}"
            
            # Check for weak protocols
            protocols = analysis.get("protocols", {})
            for protocol, supported in protocols.items():
                if supported and protocol in ["SSLv2", "SSLv3", "TLSv1.0", "TLSv1.1"]:
                    severity = Severity.HIGH if protocol in ["SSLv2", "SSLv3"] else Severity.MEDIUM
                    
                    vuln = Vulnerability(
                        title=f"Weak SSL/TLS Protocol: {protocol}",
                        description=f"Server supports weak protocol {protocol} on port {port}",
                        severity=severity,
                        affected_component=port_str,
                        recommendation=f"Disable {protocol} and use TLS 1.2 or higher",
                        evidence={
                            "protocol": protocol,
                            "port": port,
                            "supported_protocols": protocols
                        }
                    )
                    self.add_vulnerability(vuln)
            
            # Check certificate issues
            cert_info = analysis.get("certificate", {})
            if cert_info:
                # Check expiry
                days_until_expiry = cert_info.get("days_until_expiry", 0)
                if days_until_expiry < 0:
                    vuln = Vulnerability(
                        title="Expired SSL Certificate",
                        description=f"SSL certificate on port {port} has expired",
                        severity=Severity.HIGH,
                        affected_component=port_str,
                        recommendation="Renew the SSL certificate immediately",
                        evidence=cert_info
                    )
                    self.add_vulnerability(vuln)
                elif days_until_expiry < 30:
                    vuln = Vulnerability(
                        title="SSL Certificate Expiring Soon",
                        description=f"SSL certificate on port {port} expires in {days_until_expiry} days",
                        severity=Severity.MEDIUM,
                        affected_component=port_str,
                        recommendation="Renew the SSL certificate before expiration",
                        evidence=cert_info
                    )
                    self.add_vulnerability(vuln)
                
                # Check key size
                key_size = cert_info.get("key_size", 0)
                if key_size and key_size < 2048:
                    vuln = Vulnerability(
                        title="Weak SSL Certificate Key",
                        description=f"SSL certificate uses weak key size: {key_size} bits",
                        severity=Severity.HIGH,
                        affected_component=port_str,
                        recommendation="Use at least 2048-bit RSA or 256-bit ECC keys",
                        evidence=cert_info
                    )
                    self.add_vulnerability(vuln)
                
                # Check signature algorithm
                sig_algo = cert_info.get("signature_algorithm", "").lower()
                if any(weak in sig_algo for weak in ["md5", "sha1"]):
                    vuln = Vulnerability(
                        title="Weak Certificate Signature Algorithm",
                        description=f"Certificate uses weak signature algorithm: {sig_algo}",
                        severity=Severity.MEDIUM,
                        affected_component=port_str,
                        recommendation="Use SHA-256 or stronger signature algorithms",
                        evidence=cert_info
                    )
                    self.add_vulnerability(vuln)
            
            # Check for specific vulnerabilities
            vulns = analysis.get("vulnerabilities", [])
            for vuln_name in vulns:
                severity = Severity.CRITICAL if vuln_name == "Heartbleed" else Severity.HIGH
                
                vuln = Vulnerability(
                    title=f"SSL/TLS Vulnerability: {vuln_name}",
                    description=f"Server is vulnerable to {vuln_name} attack on port {port}",
                    severity=severity,
                    affected_component=port_str,
                    recommendation=f"Apply patches and configuration changes to fix {vuln_name}",
                    evidence={
                        "vulnerability": vuln_name,
                        "port": port,
                        "test_results": analysis
                    }
                )
                self.add_vulnerability(vuln)