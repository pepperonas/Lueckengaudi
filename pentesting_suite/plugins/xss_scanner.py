import asyncio
import aiohttp
import urllib.parse
from typing import Dict, Any, List, Tuple
from datetime import datetime
import re
import html
import sys
sys.path.append('..')

from core.base_plugin import BasePlugin, PluginResult, PluginStatus, Vulnerability, Severity


class XSSScanner(BasePlugin):
    def __init__(self):
        super().__init__(
            name="XSSScanner",
            version="1.0.0",
            description="Cross-Site Scripting (XSS) vulnerability scanner"
        )
        
        # XSS payloads for different contexts
        self.payloads = {
            "reflected": [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "javascript:alert('XSS')",
                "<iframe src=javascript:alert('XSS')></iframe>",
                "<input type='text' value='' onclick=alert('XSS')>",
                "<body onload=alert('XSS')>",
                "<div onmouseover=alert('XSS')>test</div>",
                "'><script>alert('XSS')</script>",
                "\"><script>alert('XSS')</script>",
                "</script><script>alert('XSS')</script>",
                "<script>confirm('XSS')</script>",
                "<script>prompt('XSS')</script>"
            ],
            "dom_based": [
                "#<script>alert('XSS')</script>",
                "javascript:alert('XSS')",
                "data:text/html,<script>alert('XSS')</script>",
                "<img src=# onerror=alert('XSS')>",
                "<svg/onload=alert('XSS')>",
                "<iframe src=javascript:alert('XSS')>",
                "javascript:/*--></title></style></textarea></script></xmp><svg/onload='+/\"/+/onmouseover=1/+/[*/[]/+alert('XSS')//'>"
            ],
            "stored": [
                "<script>alert('Stored XSS')</script>",
                "<img src=x onerror=alert('Stored XSS')>",
                "<svg onload=alert('Stored XSS')>",
                "<iframe src=javascript:alert('Stored XSS')></iframe>",
                "<body onload=alert('Stored XSS')>",
                "<div onmouseover=alert('Stored XSS')>Hover me</div>"
            ],
            "filter_bypass": [
                "<ScRiPt>alert('XSS')</ScRiPt>",
                "<script>alert(String.fromCharCode(88,83,83))</script>",
                "<script>alert(/XSS/.source)</script>",
                "<script>alert`XSS`</script>",
                "<script>eval('alert(\"XSS\")')</script>",
                "<script>window['alert']('XSS')</script>",
                "<script>top['alert']('XSS')</script>",
                "<script>parent['alert']('XSS')</script>",
                "<script>[]['constructor']['constructor']('alert(\"XSS\")')['constructor']()</script>",
                "<<SCRIPT>alert('XSS');//<</SCRIPT>",
                "<script>/**/alert('XSS')/**/</script>",
                "<script>alert('XS'+'S')</script>",
                "<script>alert(String(String).fromCharCode(88,83,83))</script>"
            ],
            "attribute_based": [
                "\" onmouseover=alert('XSS') \"",
                "' onmouseover=alert('XSS') '",
                "onmouseover=alert('XSS')",
                "\" autofocus onfocus=alert('XSS') \"",
                "' autofocus onfocus=alert('XSS') '",
                "\" onclick=alert('XSS') \"",
                "' onclick=alert('XSS') '",
                "javascript:alert('XSS')",
                "vbscript:alert('XSS')",
                "data:text/html,<script>alert('XSS')</script>"
            ]
        }
        
        # Common XSS detection patterns in responses
        self.detection_patterns = [
            r"<script[^>]*>.*?alert\s*\(\s*['\"].*?['\"].*?\).*?</script>",
            r"<img[^>]*onerror\s*=\s*['\"]?alert\s*\(",
            r"<svg[^>]*onload\s*=\s*['\"]?alert\s*\(",
            r"<iframe[^>]*src\s*=\s*['\"]?javascript:",
            r"<body[^>]*onload\s*=\s*['\"]?alert\s*\(",
            r"<div[^>]*onmouseover\s*=\s*['\"]?alert\s*\(",
            r"<input[^>]*onclick\s*=\s*['\"]?alert\s*\(",
            r"javascript:\s*alert\s*\(",
            r"alert\s*\(\s*['\"].*?['\"].*?\)",
            r"confirm\s*\(\s*['\"].*?['\"].*?\)",
            r"prompt\s*\(\s*['\"].*?['\"].*?\)"
        ]
        
        # Context-specific detection
        self.context_patterns = {
            "script_context": [
                r"<script[^>]*>.*?{payload}.*?</script>",
                r"javascript:.*?{payload}",
                r"<script[^>]*>{payload}</script>"
            ],
            "attribute_context": [
                r'<[^>]+\s+\w+\s*=\s*[\'"]?[^>]*{payload}[^>]*[\'"]?[^>]*>',
                r'<[^>]+\s+on\w+\s*=\s*[\'"]?[^>]*{payload}[^>]*[\'"]?[^>]*>'
            ],
            "html_context": [
                r'<[^>]*>{payload}</[^>]*>',
                r'{payload}(?=<|$)'
            ]
        }
        
        # Common parameter names to test
        self.common_params = [
            "q", "search", "query", "keyword", "term", "name", "email",
            "message", "comment", "content", "text", "data", "value",
            "input", "field", "param", "var", "val", "str", "string"
        ]
    
    def validate_options(self, options: Dict[str, Any]) -> bool:
        return "url" in options
    
    async def execute(self, target: str, options: Dict[str, Any]) -> PluginResult:
        self.status = PluginStatus.RUNNING
        
        url = options.get("url", f"http://{target}")
        if not url.startswith(("http://", "https://")):
            url = f"http://{url}"
        
        max_concurrent = options.get("max_concurrent", 10)
        timeout = options.get("timeout", 10)
        test_params = options.get("params", self.common_params)
        test_stored = options.get("test_stored", False)
        
        vulnerabilities_found = []
        
        try:
            connector = aiohttp.TCPConnector(limit=max_concurrent)
            timeout_config = aiohttp.ClientTimeout(total=timeout)
            
            async with aiohttp.ClientSession(
                connector=connector,
                timeout=timeout_config,
                headers={"User-Agent": "Mozilla/5.0 (Compatible XSS Scanner)"}
            ) as session:
                
                # Test different XSS attack vectors
                vulnerabilities_found.extend(await self._test_reflected_xss(session, url, test_params))
                vulnerabilities_found.extend(await self._test_dom_xss(session, url))
                
                if test_stored:
                    vulnerabilities_found.extend(await self._test_stored_xss(session, url, test_params))
                
                vulnerabilities_found.extend(await self._test_header_xss(session, url))
                vulnerabilities_found.extend(await self._test_cookie_xss(session, url))
                
        except Exception as e:
            self.status = PluginStatus.FAILED
            return PluginResult(
                plugin_name=self.name,
                status=self.status,
                data={"error": str(e)},
                errors=[str(e)]
            )
        
        # Add vulnerabilities to the plugin
        for vuln_data in vulnerabilities_found:
            vuln = Vulnerability(
                title=f"Cross-Site Scripting (XSS) - {vuln_data['type']}",
                description=vuln_data['description'],
                severity=vuln_data['severity'],
                affected_component=vuln_data['url'],
                recommendation=vuln_data['recommendation'],
                evidence=vuln_data['evidence']
            )
            self.add_vulnerability(vuln)
        
        self.status = PluginStatus.COMPLETED
        result_data = {
            "target": target,
            "url": url,
            "vulnerabilities_found": len(vulnerabilities_found),
            "vulnerability_details": vulnerabilities_found,
            "timestamp": datetime.now().isoformat()
        }
        
        result = PluginResult(
            plugin_name=self.name,
            status=self.status,
            data=result_data,
            timestamp=datetime.now().isoformat()
        )
        
        self.results.append(result)
        return result
    
    async def _test_reflected_xss(self, session: aiohttp.ClientSession, url: str, params: List[str]) -> List[Dict]:
        """Test for reflected XSS vulnerabilities"""
        vulnerabilities = []
        
        for param in params:
            for payload_type in ["reflected", "filter_bypass", "attribute_based"]:
                payloads = self.payloads[payload_type]
                
                for payload in payloads[:3]:  # Limit payloads per parameter
                    vuln = await self._test_xss_parameter(session, url, param, payload, "GET", "Reflected")
                    if vuln:
                        vulnerabilities.append(vuln)
                        break  # Found vulnerability, move to next parameter
                
                # Also test POST method
                for payload in payloads[:2]:  # Fewer payloads for POST
                    vuln = await self._test_xss_parameter(session, url, param, payload, "POST", "Reflected")
                    if vuln:
                        vulnerabilities.append(vuln)
                        break
        
        return vulnerabilities
    
    async def _test_dom_xss(self, session: aiohttp.ClientSession, url: str) -> List[Dict]:
        """Test for DOM-based XSS vulnerabilities"""
        vulnerabilities = []
        
        # Test URL fragments and hash parameters
        for payload in self.payloads["dom_based"][:5]:
            test_url = f"{url}#{urllib.parse.quote(payload)}"
            vuln = await self._test_dom_payload(session, test_url, payload)
            if vuln:
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _test_stored_xss(self, session: aiohttp.ClientSession, url: str, params: List[str]) -> List[Dict]:
        """Test for stored XSS vulnerabilities"""
        vulnerabilities = []
        
        # This is a basic implementation - stored XSS testing typically requires
        # multiple requests and form submission detection
        for param in params[:3]:  # Limit stored XSS testing
            for payload in self.payloads["stored"][:2]:
                vuln = await self._test_xss_parameter(session, url, param, payload, "POST", "Stored")
                if vuln:
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _test_header_xss(self, session: aiohttp.ClientSession, url: str) -> List[Dict]:
        """Test for XSS in HTTP headers"""
        vulnerabilities = []
        
        headers_to_test = ["User-Agent", "Referer", "X-Forwarded-For", "X-Real-IP"]
        
        for header in headers_to_test:
            for payload in self.payloads["reflected"][:2]:
                vuln = await self._test_header_payload(session, url, header, payload)
                if vuln:
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _test_cookie_xss(self, session: aiohttp.ClientSession, url: str) -> List[Dict]:
        """Test for XSS in cookies"""
        vulnerabilities = []
        
        cookie_names = ["session", "user", "token", "data"]
        
        for cookie_name in cookie_names:
            for payload in self.payloads["reflected"][:2]:
                vuln = await self._test_cookie_payload(session, url, cookie_name, payload)
                if vuln:
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _test_xss_parameter(self, session: aiohttp.ClientSession, url: str, param: str, 
                                 payload: str, method: str, xss_type: str) -> Dict:
        """Test a specific parameter with an XSS payload"""
        if self._rate_limiter:
            async with self._rate_limiter:
                return await self._perform_xss_test(session, url, param, payload, method, xss_type)
        return await self._perform_xss_test(session, url, param, payload, method, xss_type)
    
    async def _perform_xss_test(self, session: aiohttp.ClientSession, url: str, 
                               param: str, payload: str, method: str, xss_type: str) -> Dict:
        """Perform the actual XSS test"""
        try:
            if method == "GET":
                test_url = f"{url}?{param}={urllib.parse.quote(payload)}"
                async with session.get(test_url) as response:
                    content = await response.text()
                    return self._analyze_xss_response(response, content, test_url, param, payload, xss_type)
            
            elif method == "POST":
                data = {param: payload}
                async with session.post(url, data=data) as response:
                    content = await response.text()
                    return self._analyze_xss_response(response, content, url, param, payload, xss_type)
        
        except Exception:
            pass
        
        return {}
    
    async def _test_dom_payload(self, session: aiohttp.ClientSession, test_url: str, payload: str) -> Dict:
        """Test DOM-based XSS payload"""
        try:
            async with session.get(test_url) as response:
                content = await response.text()
                if self._detect_dom_xss(content, payload):
                    return {
                        "type": "DOM-based",
                        "description": f"DOM-based XSS vulnerability found. Payload: {payload}",
                        "severity": Severity.HIGH,
                        "url": test_url,
                        "recommendation": "Sanitize DOM manipulation and avoid eval() functions",
                        "evidence": {
                            "payload": payload,
                            "injection_point": "URL fragment",
                            "response_status": response.status
                        }
                    }
        except Exception:
            pass
        
        return {}
    
    async def _test_header_payload(self, session: aiohttp.ClientSession, url: str, 
                                  header_name: str, payload: str) -> Dict:
        """Test XSS in HTTP headers"""
        try:
            headers = {header_name: payload}
            async with session.get(url, headers=headers) as response:
                content = await response.text()
                if self._detect_xss_in_content(content, payload):
                    return {
                        "type": "Header-based",
                        "description": f"XSS vulnerability found in {header_name} header",
                        "severity": Severity.MEDIUM,
                        "url": url,
                        "recommendation": "Sanitize and validate HTTP headers before output",
                        "evidence": {
                            "header": header_name,
                            "payload": payload,
                            "injection_point": "HTTP header",
                            "response_status": response.status
                        }
                    }
        except Exception:
            pass
        
        return {}
    
    async def _test_cookie_payload(self, session: aiohttp.ClientSession, url: str, 
                                  cookie_name: str, payload: str) -> Dict:
        """Test XSS in cookies"""
        try:
            cookies = {cookie_name: payload}
            async with session.get(url, cookies=cookies) as response:
                content = await response.text()
                if self._detect_xss_in_content(content, payload):
                    return {
                        "type": "Cookie-based",
                        "description": f"XSS vulnerability found in {cookie_name} cookie",
                        "severity": Severity.MEDIUM,
                        "url": url,
                        "recommendation": "Sanitize cookie values before output",
                        "evidence": {
                            "cookie": cookie_name,
                            "payload": payload,
                            "injection_point": "Cookie",
                            "response_status": response.status
                        }
                    }
        except Exception:
            pass
        
        return {}
    
    def _analyze_xss_response(self, response, content: str, url: str, param: str, 
                             payload: str, xss_type: str) -> Dict:
        """Analyze response for XSS indicators"""
        
        if self._detect_xss_in_content(content, payload):
            severity = Severity.HIGH if xss_type == "Stored" else Severity.MEDIUM
            
            return {
                "type": xss_type,
                "description": f"{xss_type} XSS vulnerability found in {param} parameter",
                "severity": severity,
                "url": url,
                "recommendation": "Implement proper input validation and output encoding",
                "evidence": {
                    "parameter": param,
                    "payload": payload,
                    "injection_point": "Parameter",
                    "response_status": response.status,
                    "context": self._determine_context(content, payload)
                }
            }
        
        return {}
    
    def _detect_xss_in_content(self, content: str, payload: str) -> bool:
        """Detect XSS payload execution in response content"""
        
        # Check if the payload appears unescaped in the response
        if payload in content:
            return True
        
        # Check for HTML-decoded versions
        decoded_payload = html.unescape(payload)
        if decoded_payload in content:
            return True
        
        # Check for partial payload matches (in case of filtering)
        payload_parts = payload.lower().split()
        for part in payload_parts:
            if len(part) > 3 and part in content.lower():
                # Check if it's in a dangerous context
                if any(pattern in content.lower() for pattern in ["script", "onerror", "onload", "onclick"]):
                    return True
        
        # Check against detection patterns
        for pattern in self.detection_patterns:
            if re.search(pattern, content, re.IGNORECASE | re.DOTALL):
                return True
        
        return False
    
    def _detect_dom_xss(self, content: str, payload: str) -> bool:
        """Detect DOM-based XSS indicators"""
        
        # Look for JavaScript that processes location.hash or other DOM sources
        dom_sources = [
            r"location\.hash",
            r"location\.search", 
            r"document\.URL",
            r"document\.referrer",
            r"window\.name",
            r"document\.location"
        ]
        
        # Look for dangerous sinks
        dom_sinks = [
            r"innerHTML",
            r"outerHTML",
            r"document\.write",
            r"document\.writeln",
            r"eval\s*\(",
            r"setTimeout\s*\(",
            r"setInterval\s*\("
        ]
        
        has_source = any(re.search(source, content, re.IGNORECASE) for source in dom_sources)
        has_sink = any(re.search(sink, content, re.IGNORECASE) for sink in dom_sinks)
        
        # If we find both source and sink, it's potentially vulnerable
        if has_source and has_sink:
            return True
        
        # Also check if our payload would execute
        return self._detect_xss_in_content(content, payload)
    
    def _determine_context(self, content: str, payload: str) -> str:
        """Determine the context where the payload appears"""
        
        # Find the position of the payload in the content
        payload_pos = content.find(payload)
        if payload_pos == -1:
            return "unknown"
        
        # Get surrounding context
        start = max(0, payload_pos - 100)
        end = min(len(content), payload_pos + len(payload) + 100)
        context = content[start:end]
        
        # Determine context type
        if re.search(r'<script[^>]*>.*?' + re.escape(payload), context, re.IGNORECASE):
            return "script"
        elif re.search(r'<[^>]+\s+\w+\s*=\s*[\'"]?[^>]*' + re.escape(payload), context, re.IGNORECASE):
            return "attribute"
        elif re.search(r'<[^>]*>' + re.escape(payload) + '</[^>]*>', context, re.IGNORECASE):
            return "html"
        else:
            return "text"